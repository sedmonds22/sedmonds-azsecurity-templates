{
  "ruleCount": 92,
  "rules": [
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Microsoft Entra ID Hybrid Health AD FS New Server",
      "id": "88f453ff-7b9e-45bb-8c12-4058ca5e44ee",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "'This detection uses AzureActivity logs (Administrative category) to identify the creation or update of a server instance in an Microsoft Entra ID Hybrid Health AD FS service.\nA threat actor can create a new AD Health ADFS service and create a fake server instance to spoof AD FS signing logs. There is no need to compromise an on-premises AD FS server.\nThis can be done programmatically via HTTP requests to Azure. More information in this blog: https://o365blog.com/post/hybridhealthagent/'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AADHybridHealthADFSNewServer.yaml",
      "queryFrequency": "PT1D",
      "query": "AzureActivity\n| where CategoryValue =~ 'Administrative'\n| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'\n| where _ResourceId has 'AdFederationService'\n| where OperationNameValue =~ 'Microsoft.ADHybridHealthService/services/servicemembers/action'\n| extend claimsJson = parse_json(Claims)\n| extend AppId = tostring(claimsJson.appid), AccountName = tostring(claimsJson.name), Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])\n| project-away claimsJson",
      "techniques": "T1578",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Microsoft Entra ID Hybrid Health AD FS Service Delete",
      "id": "86a036b2-3686-42eb-b417-909fc0867771",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "'This detection uses AzureActivity logs (Administrative category) to identify the deletion of an Microsoft Entra ID Hybrid Health AD FS service instance in a tenant.\nA threat actor can create a new AD Health ADFS service and create a fake server to spoof AD FS signing logs.\nThe health AD FS service can then be deleted after it is no longer needed via HTTP requests to Azure.\nMore information is available in this blog https://o365blog.com/post/hybridhealthagent/'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AADHybridHealthADFSServiceDelete.yaml",
      "queryFrequency": "PT1D",
      "query": "AzureActivity\n| where CategoryValue =~ 'Administrative'\n| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'\n| where _ResourceId has 'AdFederationService'\n| where OperationNameValue =~ 'Microsoft.ADHybridHealthService/services/delete'\n| extend claimsJson = parse_json(Claims)\n| extend AppId = tostring(claimsJson.appid), AccountName = tostring(claimsJson.name), Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])\n| project-away claimsJson",
      "techniques": "T1578.003",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Microsoft Entra ID Hybrid Health AD FS Suspicious Application",
      "id": "d9938c3b-16f9-444d-bc22-ea9a9110e0fd",
      "tactics": [
        "CredentialAccess",
        "DefenseEvasion"
      ],
      "kind": "Scheduled",
      "description": "'This detection uses AzureActivity logs (Administrative category) to identify a suspicious application adding a server instance to an Microsoft Entra ID Hybrid Health AD FS service or deleting the AD FS service instance.\nUsually the Microsoft Entra ID Connect Health Agent application with ID cf6d7e68-f018-4e0a-a7b3-126e053fb88d and ID cb1056e2-e479-49de-ae31-7812af012ed8 is used to perform those operations.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AADHybridHealthADFSSuspApp.yaml",
      "queryFrequency": "PT1D",
      "query": "// Microsoft Entra ID Connect Health Agent - cf6d7e68-f018-4e0a-a7b3-126e053fb88d\n// Microsoft Entra ID Connect - cb1056e2-e479-49de-ae31-7812af012ed8\nlet appList = dynamic(['cf6d7e68-f018-4e0a-a7b3-126e053fb88d','cb1056e2-e479-49de-ae31-7812af012ed8']);\nlet operationNamesList = dynamic(['Microsoft.ADHybridHealthService/services/servicemembers/action','Microsoft.ADHybridHealthService/services/delete']);\nAzureActivity\n| where CategoryValue =~ 'Administrative'\n| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'\n| where _ResourceId has 'AdFederationService'\n| where OperationNameValue in~ (operationNamesList)\n| extend claimsJson = parse_json(Claims)\n| extend AppId = tostring(claimsJson.appid), AccountName = tostring(claimsJson.name), Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])\n| where AppId !in (appList)\n| project-away claimsJson",
      "techniques": [
        "T1528",
        "T1550"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "TargetUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "CreatedByUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "CreatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "CreatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "CreatedByAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "DeletedByUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "DeletedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "DeletedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "DeletedByAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CreatedByIPAddress"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "DeletedByIPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Account Created and Deleted in Short Timeframe",
      "id": "bb616d82-108f-47d3-9dec-9652ea0d3bf6",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "'Search for user principal name (UPN) events. Look for accounts created and then deleted in under 24 hours. Attackers may create an account for their use, and then remove the account when no longer needed.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#short-lived-account'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AccountCreatedandDeletedinShortTimeframe.yaml",
      "queryFrequency": "PT1H",
      "query": "let queryfrequency = 1h;\nlet queryperiod = 1d;\nAuditLogs\n| where TimeGenerated > ago(queryfrequency)\n| where OperationName =~ \"Delete user\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type == \"User\"\n      | extend TargetUserPrincipalName = extract(@'([a-f0-9]{32})?(.*)', 2, tostring(TargetResource.userPrincipalName))\n  )\n| extend DeletedByApp = tostring(InitiatedBy.app.displayName),\nDeletedByAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId),\nDeletedByUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName),\nDeletedByAadUserId = tostring(InitiatedBy.user.id),\nDeletedByIPAddress = tostring(InitiatedBy.user.ipAddress)\n| project Deletion_TimeGenerated = TimeGenerated, TargetUserPrincipalName, DeletedByApp, DeletedByAppServicePrincipalId, DeletedByUserPrincipalName, DeletedByAadUserId, DeletedByIPAddress, \nDeletion_AdditionalDetails = AdditionalDetails, Deletion_InitiatedBy = InitiatedBy, Deletion_TargetResources = TargetResources\n| join kind=inner (\n    AuditLogs\n    | where TimeGenerated > ago(queryperiod)\n    | where OperationName =~ \"Add user\"      \n    | mv-apply TargetResource = TargetResources on \n      (\n          where TargetResource.type == \"User\"\n          | extend TargetUserPrincipalName = trim(@'\"',tostring(TargetResource.userPrincipalName))\n      )\n    | project-rename Creation_TimeGenerated = TimeGenerated\n) on TargetUserPrincipalName\n| extend TimeDelta = Deletion_TimeGenerated - Creation_TimeGenerated\n| where  TimeDelta between (time(0s) .. queryperiod)\n| extend CreatedByApp = tostring(InitiatedBy.app.displayName),\nCreatedByAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId),\nCreatedByUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName),\nCreatedByAadUserId = tostring(InitiatedBy.user.id),\nCreatedByIPAddress = tostring(InitiatedBy.user.ipAddress)\n| project Creation_TimeGenerated, Deletion_TimeGenerated, TimeDelta, TargetUserPrincipalName, DeletedByApp, DeletedByAppServicePrincipalId, DeletedByUserPrincipalName, DeletedByAadUserId, DeletedByIPAddress, \nCreatedByApp, CreatedByAppServicePrincipalId, CreatedByUserPrincipalName, CreatedByAadUserId, CreatedByIPAddress, Creation_AdditionalDetails = AdditionalDetails, Creation_InitiatedBy = InitiatedBy, Creation_TargetResources = TargetResources, Deletion_AdditionalDetails, Deletion_InitiatedBy, Deletion_TargetResources\n| extend TargetName = tostring(split(TargetUserPrincipalName,'@',0)[0]), TargetUPNSuffix = tostring(split(TargetUserPrincipalName,'@',1)[0])\n| extend CreatedByName = tostring(split(CreatedByUserPrincipalName,'@',0)[0]), CreatedByUPNSuffix = tostring(split(CreatedByUserPrincipalName,'@',1)[0])\n| extend DeletedByName = tostring(split(DeletedByUserPrincipalName,'@',0)[0]), DeletedByUPNSuffix = tostring(split(DeletedByUserPrincipalName,'@',1)[0])",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Account created or deleted by non-approved user",
      "id": "6d63efa6-7c25-4bd4-a486-aa6bf50fde8a",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "'Identifies accounts that were created or deleted by a defined list of non-approved user principal names. Add to this list before running the query for accurate results.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AccountCreatedDeletedByNonApprovedUser.yaml",
      "queryFrequency": "PT1D",
      "query": "// Add non-approved user principal names or apps to the list below to search for their account creation/deletion activity\n// ex: dynamic([\"UPN1\", \"upn123\"])\nlet nonapproved_users = dynamic([]);\nlet nonapproved_apps = dynamic([]);\nAuditLogs\n| where OperationName =~ \"Add user\" or OperationName =~ \"Delete user\"\n| where Result =~ \"success\"\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| where InitiatingUserPrincipalName has_any (nonapproved_users) or InitiatingAppName has_any (nonapproved_apps)\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Modified domain federation trust settings",
      "id": "95dc4ae3-e0f2-48bd-b996-cdd22b90f9af",
      "tactics": [
        "CredentialAccess",
        "Persistence",
        "PrivilegeEscalation"
      ],
      "kind": "Scheduled",
      "description": "'This will alert when a user or application modifies the federation settings on the domain or Update domain authentication from Managed to Federated.\nFor example, this alert will trigger when a new Active Directory Federated Service (ADFS) TrustedRealm object, such as a signing certificate, is added to the domain.\nModification to domain federation settings should be rare. Confirm the added or modified target domain/URL is legitimate administrator behavior.\nTo understand why an authorized user may update settings for a federated domain in Office 365, Azure, or Intune, see: https://docs.microsoft.com/office365/troubleshoot/active-directory/update-federated-domain-office-365.\nFor details on security realms that accept security tokens, see the ADFS Proxy Protocol (MS-ADFSPP) specification: https://docs.microsoft.com/openspecs/windows_protocols/ms-adfspp/e7b9ea73-1980-4318-96a6-da559486664b.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "ADFSDomainTrustMods.yaml",
      "queryFrequency": "PT1D",
      "query": "(union isfuzzy=true\n(\nAuditLogs\n| where OperationName =~ \"Set federation settings on domain\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-expand modifiedProperties\n| extend targetDisplayName = tostring(parse_json(modifiedProperties).displayName)\n),\n(\nAuditLogs\n| where OperationName =~ \"Set domain authentication\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-expand modifiedProperties\n| mv-apply Property = modifiedProperties on\n  (\n      where Property.displayName =~ \"LiveType\"\n      | extend targetDisplayName = tostring(Property.displayName),\n               NewDomainValue = tostring(Property.newValue)\n  )\n| where NewDomainValue has \"Federated\"\n)\n)\n| mv-apply AdditionalDetail = AdditionalDetails on\n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, AADOperationType, targetDisplayName, Result, InitiatingIpAddress, UserAgent, CorrelationId, TenantId, AADTenantId",
      "techniques": [
        "T1555",
        "T1098"
      ],
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Address",
            "columnName": "IPAddress"
          }
        ],
        "entityType": "IP"
      },
      "queryPeriod": "PT1H",
      "name": "Password spray attack against ADFSSignInLogs",
      "id": "5533fe80-905e-49d5-889a-df27d2c3976d",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'Identifies evidence of password spray activity against Connect Health for AD FS sign-in events by looking for failures from multiple accounts from the same IP address within a time window.\nReference: https://adfshelp.microsoft.com/References/ConnectHealthErrorCodeReference'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "ADFSSignInLogsPasswordSpray.yaml",
      "queryFrequency": "PT30M",
      "query": "let queryfrequency = 30m;\nlet accountthreshold = 10;\nlet successCodes = dynamic([0, 50144]);\nADFSSignInLogs\n| extend IngestionTime = ingestion_time()\n| where IngestionTime > ago(queryfrequency)\n| where not(todynamic(AuthenticationDetails)[0].authenticationMethod == \"Integrated Windows Authentication\")\n| summarize\n    DistinctFailureCount = dcountif(UserPrincipalName, ResultType !in (successCodes)),\n    DistinctSuccessCount = dcountif(UserPrincipalName, ResultType in (successCodes)),\n    SuccessAccounts = make_set_if(UserPrincipalName, ResultType in (successCodes), 250),\n    arg_min(TimeGenerated, *)\n    by IPAddress\n| where DistinctFailureCount > DistinctSuccessCount and DistinctFailureCount >= accountthreshold\n//| extend SuccessAccounts = iff(array_length(SuccessAccounts) != 0, SuccessAccounts, dynamic([\"null\"]))\n//| mv-expand SuccessAccounts\n| project TimeGenerated, Category, OperationName, IPAddress, DistinctFailureCount, DistinctSuccessCount, SuccessAccounts, AuthenticationRequirement, ConditionalAccessStatus, IsInteractive, UserAgent, NetworkLocationDetails, DeviceDetail, TokenIssuerType, TokenIssuerName, ResourceIdentity",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "AppDisplayName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "AppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Target"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "PermissionGrant_InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "PermissionGrant_InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "PermissionGrant_InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "PermissionGrant_InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "RoleAssignment_InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "RoleAssignment_InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "RoleAssignment_InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "RoleAssignment_InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        }
      ],
      "queryPeriod": "PT2H",
      "name": "Admin promotion after Role Management Application Permission Grant",
      "id": "f80d951a-eddc-4171-b9d0-d616bb83efdc",
      "tactics": [
        "PrivilegeEscalation",
        "Persistence"
      ],
      "kind": "Scheduled",
      "description": "'This rule looks for a service principal being granted the Microsoft Graph RoleManagement.ReadWrite.Directory (application) permission before being used to add an Microsoft Entra ID object or user account to an Admin directory role (i.e. Global Administrators).\nThis is a known attack path that is usually abused when a service principal already has the AppRoleAssignment.ReadWrite.All permission granted. This permission allows an app to manage permission grants for application permissions to any API.\nA service principal can promote itself or other service principals to admin roles (i.e. Global Administrators). This would be considered a privilege escalation technique.\nRef : https://docs.microsoft.com/graph/permissions-reference#role-management-permissions, https://docs.microsoft.com/graph/api/directoryrole-post-members?view=graph-rest-1.0&tabs=http'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AdminPromoAfterRoleMgmtAppPermissionGrant.yaml",
      "queryFrequency": "PT1H",
      "query": "let query_frequency = 1h;\nlet query_period = 2h;\nAuditLogs\n| where TimeGenerated > ago(query_period)\n| where Category =~ \"ApplicationManagement\" and LoggedByService =~ \"Core Directory\"\n| where OperationName =~ \"Add app role assignment to service principal\"\n| mv-expand TargetResource = TargetResources\n| mv-expand modifiedProperty = TargetResource[\"modifiedProperties\"]\n| where tostring(modifiedProperty[\"displayName\"]) == \"AppRole.Value\"\n| extend PermissionGrant = tostring(modifiedProperty[\"newValue\"])\n| where PermissionGrant has \"RoleManagement.ReadWrite.Directory\"\n| mv-apply modifiedProperty = TargetResource[\"modifiedProperties\"] on (\n    summarize modifiedProperties = make_bag(\n        bag_pack(tostring(modifiedProperty[\"displayName\"]),\n            bag_pack(\"oldValue\", trim(@'[\\\"\\s]+', tostring(modifiedProperty[\"oldValue\"])),\n                \"newValue\", trim(@'[\\\"\\s]+', tostring(modifiedProperty[\"newValue\"])))), 100)\n)\n| project\n    PermissionGrant_TimeGenerated = TimeGenerated,\n    PermissionGrant_OperationName = OperationName,\n    PermissionGrant_Result = Result,\n    PermissionGrant,\n    AppDisplayName = tostring(modifiedProperties[\"ServicePrincipal.DisplayName\"][\"newValue\"]),\n    AppServicePrincipalId = tostring(modifiedProperties[\"ServicePrincipal.ObjectID\"][\"newValue\"]),\n    PermissionGrant_InitiatedBy = InitiatedBy,\n    PermissionGrant_TargetResources = TargetResources,\n    PermissionGrant_AdditionalDetails = AdditionalDetails,\n    PermissionGrant_CorrelationId = CorrelationId\n| join kind=inner (\n    AuditLogs\n    | where TimeGenerated > ago(query_frequency)\n    | where Category =~ \"RoleManagement\" and LoggedByService =~ \"Core Directory\" and AADOperationType =~ \"Assign\"\n    | where isnotempty(InitiatedBy[\"app\"])\n    | mv-expand TargetResource = TargetResources\n    | mv-expand modifiedProperty = TargetResource[\"modifiedProperties\"]\n    | where tostring(modifiedProperty[\"displayName\"]) in (\"Role.DisplayName\", \"RoleDefinition.DisplayName\")\n    | extend RoleAssignment = tostring(modifiedProperty[\"newValue\"])\n    | where RoleAssignment contains \"Admin\"\n    | project\n        RoleAssignment_TimeGenerated = TimeGenerated,\n        RoleAssignment_OperationName = OperationName,\n        RoleAssignment_Result = Result,\n        RoleAssignment,\n        TargetType = tostring(TargetResources[0][\"type\"]),\n        Target = iff(isnotempty(TargetResources[0][\"displayName\"]), tostring(TargetResources[0][\"displayName\"]), tolower(TargetResources[0][\"userPrincipalName\"])),\n        TargetId = tostring(TargetResources[0][\"id\"]),\n        RoleAssignment_InitiatedBy = InitiatedBy,\n        RoleAssignment_TargetResources = TargetResources,\n        RoleAssignment_AdditionalDetails = AdditionalDetails,\n        RoleAssignment_CorrelationId = CorrelationId,\n        AppServicePrincipalId = tostring(InitiatedBy[\"app\"][\"servicePrincipalId\"])\n    ) on AppServicePrincipalId\n| where PermissionGrant_TimeGenerated < RoleAssignment_TimeGenerated\n| extend\n    TargetName = tostring(split(Target, \"@\")[0]),\n    TargetUPNSuffix = tostring(split(Target, \"@\")[1])\n| project PermissionGrant_TimeGenerated, PermissionGrant_OperationName, PermissionGrant_Result, PermissionGrant, AppDisplayName, AppServicePrincipalId, PermissionGrant_InitiatedBy, PermissionGrant_TargetResources, PermissionGrant_AdditionalDetails, PermissionGrant_CorrelationId, \nRoleAssignment_TimeGenerated, RoleAssignment_OperationName, RoleAssignment_Result, RoleAssignment, TargetType, Target, TargetName, TargetUPNSuffix, TargetId, RoleAssignment_InitiatedBy, RoleAssignment_TargetResources, RoleAssignment_AdditionalDetails, RoleAssignment_CorrelationId\n| extend PermissionGrant_InitiatingUserPrincipalName = tostring(PermissionGrant_InitiatedBy.user.userPrincipalName)\n| extend PermissionGrant_InitiatingAadUserId = tostring(PermissionGrant_InitiatedBy.user.id)\n| extend PermissionGrant_InitiatingIpAddress = tostring(iff(isnotempty(PermissionGrant_InitiatedBy.user.ipAddress), PermissionGrant_InitiatedBy.user.ipAddress, PermissionGrant_InitiatedBy.app.ipAddress))\n| extend PermissionGrant_InitiatingAccountName = tostring(split(PermissionGrant_InitiatingUserPrincipalName, \"@\")[0]), PermissionGrant_InitiatingAccountUPNSuffix = tostring(split(PermissionGrant_InitiatingUserPrincipalName, \"@\")[1])\n| extend RoleAssignment_InitiatingUserPrincipalName = tostring(RoleAssignment_InitiatedBy.user.userPrincipalName)\n| extend RoleAssignment_InitiatingAadUserId = tostring(RoleAssignment_InitiatedBy.user.id)\n| extend RoleAssignment_InitiatingIpAddress = tostring(iff(isnotempty(RoleAssignment_InitiatedBy.user.ipAddress), RoleAssignment_InitiatedBy.user.ipAddress, RoleAssignment_InitiatedBy.app.ipAddress))\n| extend RoleAssignment_InitiatingAccountName = tostring(split(RoleAssignment_InitiatingUserPrincipalName, \"@\")[0]),  RoleAssignment_InitiatingAccountUPNSuffix = tostring(split(RoleAssignment_InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1098.003",
        "T1078.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "UserId"
            }
          ],
          "entityType": "Account"
        }
      ],
      "queryPeriod": "PT7D",
      "name": "Anomalous sign-in location by user account and authenticating application",
      "id": "7cb8f77d-c52f-4e46-b82f-3cf2e106224a",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "'This query over Microsoft Entra ID sign-in considers all user sign-ins for each Microsoft Entra ID application and picks out the most anomalous change in location profile for a user within an individual application.",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AnomalousUserAppSigninLocationIncrease-detection.yaml",
      "queryFrequency": "PT1D",
      "query": "// Adjust this figure to adjust how sensitive this detection is\nlet sensitivity = 2.5;\n// Adjust this figure to set the value that defines the requested estimation accuracy. The default value is 1. Possible values are 0, 1, 2, 3, 4.\nlet dcountAccuracy = 1;\nlet AuthEvents = materialize(\nunion isfuzzy=True SigninLogs, AADNonInteractiveUserSignInLogs\n| where TimeGenerated between (ago(7d) .. now())\n| where ResultType == 0\n| extend LocationDetails = LocationDetails_dynamic\n| extend Location = strcat(LocationDetails.countryOrRegion, \"-\", LocationDetails.state,\"-\", LocationDetails.city)\n| where Location != \"--\");\nAuthEvents\n| summarize dcount(Location, dcountAccuracy) by AppDisplayName, AppId, UserPrincipalName, UserId, bin(startofday(TimeGenerated), 1d)\n| where dcount_Location > 2\n| make-series CountOfLocations = sum(dcount_Location) on TimeGenerated  step 1d by AppId, UserId\n| extend (Anomalies, Score, Baseline) = series_decompose_anomalies(CountOfLocations, sensitivity, -1, 'linefit')\n| mv-expand CountOfLocations to typeof(double), TimeGenerated to typeof(datetime), Anomalies to typeof(double), Score to typeof(double), Baseline to typeof(long)\n| where Anomalies > 0 and Baseline > 0\n| join kind=inner( AuthEvents | extend TimeStamp = startofday(TimeGenerated)) on UserId, AppId\n| extend SignInDetails = bag_pack(\"TimeGenerated\", TimeGenerated1, \"Location\", Location, \"Source\", IPAddress, \"Device\", DeviceDetail_dynamic)\n| summarize SignInDetailsSet=make_set(SignInDetails, 1000) by UserId, UserPrincipalName, CountOfLocations, TimeGenerated, AppId, AppDisplayName\n| extend Name = split(UserPrincipalName, \"@\")[0], UPNSuffix = split(UserPrincipalName, \"@\")[1]",
      "techniques": "T1078",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "Authentication Methods Changed for Privileged Account",
      "id": "694c91ee-d606-4ba9-928e-405a2dd0ff0f",
      "tactics": "Persistence",
      "kind": "Scheduled",
      "description": "'Identifies authentication methods being changed for a privileged account. This could be an indication of an attacker adding an auth method to the account so they can have continued access.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AuthenticationMethodsChangedforPrivilegedAccount.yaml",
      "queryFrequency": "PT2H",
      "query": "let queryperiod = 14d;\nlet queryfrequency = 2h;\nlet security_info_actions = dynamic([\"User registered security info\", \"User changed default security info\", \"User deleted security info\", \"Admin updated security info\", \"User reviewed security info\", \"Admin deleted security info\", \"Admin registered security info\"]);\nlet VIPUsers = (\n    IdentityInfo\n    | where TimeGenerated > ago(queryperiod)\n    | mv-expand AssignedRoles\n    | where AssignedRoles contains 'Admin'\n    | summarize by AccountUPN);\nAuditLogs\n| where TimeGenerated > ago(queryfrequency)\n| where Category =~ \"UserManagement\"\n| where ActivityDisplayName in (security_info_actions)\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend TargetUserPrincipalName = tostring(TargetResource.userPrincipalName)\n  )\n| where TargetUserPrincipalName in~ (VIPUsers)\n// Uncomment the line below if you are experiencing high volumes of Target entities. If this is uncommented, the Target column will not be mapped to an entity.\n//| summarize Start=min(TimeGenerated), End=max(TimeGenerated), Actions = make_set(ResultReason, MaxSize=8), Targets=make_set(Target, MaxSize=256) by Initiator, IP, Result\n// Comment out this line below, if line above is used.\n| summarize Start=min(TimeGenerated), End=max(TimeGenerated), Actions = make_set(ResultReason, MaxSize=8) by InitiatingAppName, InitiatingAppServicePrincipalId, \nInitiatingUserPrincipalName, InitiatingAadUserId, InitiatingIpAddress, TargetUserPrincipalName, Result\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1]), \nTargetName = iff(tostring(TargetUserPrincipalName) has \"[\", \"\", tostring(split(TargetUserPrincipalName,'@',0)[0])), TargetUPNSuffix = iff(tostring(TargetUserPrincipalName) has \"[\", \"\", tostring(split(TargetUserPrincipalName,'@',1)[0]))",
      "techniques": "T1098",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "UserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "Microsoft Entra ID PowerShell accessing non-Entra ID resources",
      "id": "50574fac-f8d1-4395-81c7-78a463ff0c52",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "'This will alert when a user or application signs in using Microsoft Entra ID PowerShell to access non-Active Directory resources, such as the Azure Key Vault, which may be undesired or unauthorized behavior.\nFor capabilities and expected behavior of the Microsoft Entra ID PowerShell module, see: https://docs.microsoft.com/powershell/module/azuread/?view=azureadps-2.0.\nFor further information on Microsoft Entra ID Signin activity reports, see: https://docs.microsoft.com/azure/active-directory/reports-monitoring/concept-sign-ins.'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AzureAADPowerShellAnomaly.yaml",
      "queryFrequency": "PT1H",
      "query": "let aadFunc = (tableName:string){\ntable(tableName)\n| where AppId =~ \"1b730954-1685-4b74-9bfd-dac224a7b894\" // AppDisplayName IS Azure Active Directory PowerShell\n| where TokenIssuerType =~ \"AzureAD\"\n| where ResourceIdentity !in (\"00000002-0000-0000-c000-000000000000\", \"00000003-0000-0000-c000-000000000000\") // ResourceDisplayName IS NOT Windows Azure Active Directory OR Microsoft Graph\n| extend Status = todynamic(Status)\n| where Status.errorCode == 0 // Success\n| project-reorder IPAddress, UserAgent, ResourceDisplayName, UserDisplayName, UserId, UserPrincipalName, Type\n| order by TimeGenerated desc\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt",
      "techniques": "T1078",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "TargetAppDisplayName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "TargetAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2H",
      "name": "Microsoft Entra ID Role Management Permission Grant",
      "id": "1ff56009-db01-4615-8211-d4fda21da02d",
      "tactics": [
        "Persistence",
        "Impact"
      ],
      "kind": "Scheduled",
      "description": "'Identifies when the Microsoft Graph RoleManagement.ReadWrite.Directory (Delegated or Application) permission is granted to a service principal.\nThis permission allows an application to read and manage the role-based access control (RBAC) settings for your company's directory.\nAn adversary could use this permission to add an Microsoft Entra ID object to an Admin directory role and escalate privileges.\nRef : https://docs.microsoft.com/graph/permissions-reference#role-management-permissions\nRef : https://docs.microsoft.com/graph/api/directoryrole-post-members?view=graph-rest-1.0&tabs=http'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AzureADRoleManagementPermissionGrant.yaml",
      "queryFrequency": "PT2H",
      "query": "AuditLogs\n| where Category =~ \"ApplicationManagement\" and LoggedByService =~ \"Core Directory\" and OperationName in~ (\"Add delegated permission grant\", \"Add app role assignment to service principal\")\n| mv-apply TargetResource = TargetResources on\n  (\n      where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n      | extend props = TargetResource.modifiedProperties\n  )\n| mv-apply Property = props on\n  (\n      where Property.displayName in~ (\"AppRole.Value\",\"DelegatedPermissionGrant.Scope\")\n      | extend DisplayName = tostring(Property.displayName), PermissionGrant = trim('\"',tostring(Property.newValue))\n  )\n| where PermissionGrant has \"RoleManagement.ReadWrite.Directory\"\n| mv-apply Property = props on\n  (\n      where Property.displayName =~ \"ServicePrincipal.DisplayName\"\n      | extend TargetAppDisplayName = trim('\"',tostring(Property.newValue))\n  )\n| mv-apply Property = props on\n  (\n      where Property.displayName =~ \"ServicePrincipal.ObjectID\"\n      | extend TargetAppServicePrincipalId = trim('\"',tostring(Property.newValue))\n  )\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| project TimeGenerated, OperationName, Result, PermissionGrant, TargetAppDisplayName, TargetAppServicePrincipalId, InitiatingAppName, InitiatingAppServicePrincipalId,\nInitiatingUserPrincipalName, InitiatingAadUserId, InitiatingIpAddress, TargetResources, AdditionalDetails, CorrelationId\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1098.003",
        "T1078.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "AccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "UserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "Azure Portal sign in from another Azure Tenant",
      "id": "87210ca1-49a4-4a7d-bb4a-4988752f978c",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "'This query looks for successful sign in attempts to the Azure Portal where the user who is signing in from another Azure tenant, and the IP address the login attempt is from is an Azure IP. A threat actor who compromises an Azure tenant may look to pivot to other tenants leveraging cross-tenant delegated access in this manner.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "AzurePortalSigninfromanotherAzureTenant.yaml",
      "queryFrequency": "PT1H",
      "query": "// Get details of current Azure Ranges (note this URL updates regularly so will need to be manually updated over time)\n// You may find the name of the new JSON here: https://www.microsoft.com/download/details.aspx?id=56519\n// On the downloads page, click the 'details' button, and then replace just the filename in the URL below\nlet azure_ranges = externaldata(changeNumber: string, cloud: string, values: dynamic)\n[\"https://raw.githubusercontent.com/microsoft/mstic/master/PublicFeeds/MSFTIPRanges/ServiceTags_Public.json\"] with(format='multijson')\n| mv-expand values\n| mv-expand values.properties.addressPrefixes\n| mv-expand values_properties_addressPrefixes\n| summarize by tostring(values_properties_addressPrefixes)\n| extend isipv4 = parse_ipv4(values_properties_addressPrefixes)\n| extend isipv6 = parse_ipv6(values_properties_addressPrefixes)\n| extend ip_type = case(isnotnull(isipv4), \"v4\", \"v6\")\n| summarize make_list(values_properties_addressPrefixes) by ip_type\n;\nSigninLogs\n// Limiting to Azure Portal really reduces false positives and helps focus on potential admin activity\n| where ResultType == 0\n| where AppDisplayName =~ \"Azure Portal\"\n| extend isipv4 = parse_ipv4(IPAddress)\n| extend ip_type = case(isnotnull(isipv4), \"v4\", \"v6\")\n // Only get logons where the IP address is in an Azure range\n| join kind=fullouter (azure_ranges) on ip_type\n| extend ipv6_match = ipv6_is_in_any_range(IPAddress,  list_values_properties_addressPrefixes)\n| extend ipv4_match = ipv4_is_in_any_range(IPAddress,  list_values_properties_addressPrefixes)\n| where ipv4_match or ipv6_match \n// Limit to where the user is external to the tenant\n| where HomeTenantId != ResourceTenantId\n// Further limit it to just access to the current tenant (you can drop this if you wanted to look elsewhere as well but it helps reduce FPs)\n| where ResourceTenantId == AADTenantId\n| summarize FirstSeen = min(TimeGenerated), LastSeen = max(TimeGenerated), make_set(ResourceDisplayName) by UserPrincipalName, IPAddress, UserAgent, Location, HomeTenantId, ResourceTenantId, UserId\n| extend AccountName = split(UserPrincipalName, \"@\")[0]\n| extend UPNSuffix = split(UserPrincipalName, \"@\")[1]",
      "techniques": "T1199",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "Actor"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2H",
      "name": "Azure RBAC (Elevate Access)",
      "id": "132fdff4-c044-4855-a390-c1b71e0f833b",
      "tactics": "PrivilegeEscalation",
      "kind": "Scheduled",
      "description": "'Detects when a Global Administrator elevates access to all subscriptions and management groups in a tenant. When a Global Administrator elevates access they are assigned the User Access Administrator role at root scope. This Microsoft Sentinel Analytic Rule monitors who has elevated access in your tenant so that admins can take appropriate action. [Learn more](https://learn.microsoft.com/en-us/azure/role-based-access-control/elevate-access-global-admin?tabs=azure-portal)'",
      "severity": "High",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "AzureRBAC.yaml",
      "queryFrequency": "PT2H",
      "query": "AuditLogs\n| where Category =~ \"AzureRBACRoleManagementElevateAccess\"\n| where ActivityDisplayName =~ \"User has elevated their access to User Access Administrator for their Azure Resources\"\n| extend Actor = tostring(InitiatedBy.user.userPrincipalName)\n| extend IPAddress = tostring(InitiatedBy.user.ipAddress) \n| project\n    TimeGenerated,\n    Actor,\n    OperationName,\n    IPAddress,\n    Result,\n    LoggedByService",
      "techniques": "T1078",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "UserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddressFirst"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT7D",
      "name": "Brute Force Attack against GitHub Account",
      "id": "97ad74c4-fdd9-4a3f-b6bf-5e28f4f71e06",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'Attackers who are trying to guess your users' passwords or use brute-force methods to get in. If your organization is using SSO with Microsoft Entra ID, authentication logs to GitHub.com will be generated. Using the following query can help you identify a sudden increase in failed logon attempt of users.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Brute Force Attack against GitHub Account.yaml",
      "queryFrequency": "PT1H",
      "query": "let LearningPeriod = 7d;\nlet BinTime = 1h;\nlet RunTime = 1h;\nlet StartTime = 1h;  \nlet sensitivity = 2.5;\nlet EndRunTime = StartTime - RunTime;\nlet EndLearningTime = StartTime + LearningPeriod;\nlet aadFunc = (tableName:string){\ntable(tableName)  \n| where TimeGenerated between (ago(EndLearningTime) .. ago(EndRunTime))\n| where AppDisplayName =~ \"GitHub.com\"\n| where ResultType != 0\n| make-series FailedLogins = count() on TimeGenerated from ago(LearningPeriod) to ago(EndRunTime) step BinTime by UserPrincipalName, Type\n| extend (Anomalies, Score, Baseline) = series_decompose_anomalies(FailedLogins, sensitivity, -1, 'linefit')\n| mv-expand FailedLogins to typeof(double), TimeGenerated to typeof(datetime), Anomalies to typeof(double), Score to typeof(double), Baseline to typeof(long)  \n| where TimeGenerated >= ago(RunTime)\n| where Anomalies > 0 and Baseline > 0\n| join kind=inner (\n          table(tableName)  \n          | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime))\n          | where AppDisplayName =~ \"GitHub.com\"\n          | where ResultType != 0\n          | summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), IPAddresses = make_set(IPAddress,100), Locations = make_set(LocationDetails,20), Devices = make_set(DeviceDetail,20) by UserPrincipalName, UserId, AppDisplayName\n      ) on UserPrincipalName\n| project-away UserPrincipalName1\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])\n| extend IPAddressFirst = tostring(IPAddresses[0])\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "UserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddressFirst"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Brute force attack against a Cloud PC",
      "id": "3fbc20a4-04c4-464e-8fcb-6667f53e4987",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'Identifies evidence of brute force activity against a Windows 365 Cloud PC by highlighting multiple authentication failures and by a successful authentication within a given time window.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "BruteForceCloudPC.yaml",
      "queryFrequency": "PT1D",
      "query": "let authenticationWindow = 20m;\nlet sensitivity = 2.5;\nSigninLogs\n| where AppDisplayName =~ \"Windows Sign In\"\n| extend FailureOrSuccess = iff(ResultType in (\"0\", \"50125\", \"50140\", \"70043\", \"70044\"), \"Success\", \"Failure\")\n| summarize FailureCount = countif(FailureOrSuccess==\"Failure\"), SuccessCount = countif(FailureOrSuccess==\"Success\"), IPAddresses = make_set(IPAddress,1000)\n                          by bin(TimeGenerated, authenticationWindow), UserDisplayName, UserPrincipalName\n| extend FailureSuccessDiff = FailureCount - SuccessCount\n| where FailureSuccessDiff > 0\n| summarize Diff = make_list(FailureSuccessDiff, 10000), TimeStamp = make_list(TimeGenerated, 10000) by UserDisplayName, UserPrincipalName//, tostring(IPAddresses)\n| extend (Anomalies, Score, Baseline) = series_decompose_anomalies(Diff, sensitivity, -1, 'linefit')  \n| mv-expand Diff to typeof(double), TimeStamp to typeof(datetime), Anomalies to typeof(double), Score to typeof(double), Baseline to typeof(long)\n| where Anomalies > 0\n| summarize by UserDisplayName, UserPrincipalName, Anomalies, Score, Baseline, FailureToSuccessDiff = Diff\n| join kind=leftouter (\n      SigninLogs\n      | where AppDisplayName =~ \"Windows Sign In\"\n      | extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n      | extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n      | extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)\n      | summarize StartTime = min(TimeGenerated), \n                  EndTime = max(TimeGenerated), \n                  IPAddresses = make_set(IPAddress,100), \n                  OS = make_set(OS,20), \n                  Browser = make_set(Browser,20), \n                  City = make_set(City,100), \n                  ResultType = make_set(ResultType,100)\n              by UserDisplayName, UserPrincipalName, UserId, AppDisplayName\n  ) on UserDisplayName, UserPrincipalName\n| project-away UserDisplayName1, UserPrincipalName1\n| extend IPAddressFirst = tostring(IPAddresses[0])\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "TargetUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2H",
      "name": "Bulk Changes to Privileged Account Permissions",
      "id": "218f60de-c269-457a-b882-9966632b9dc6",
      "tactics": "PrivilegeEscalation",
      "kind": "Scheduled",
      "description": "'Identifies when changes to multiple users permissions are changed at once. Investigate immediately if not a planned change. This setting could enable an attacker access to Azure subscriptions in your environment.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-identity-management'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "BulkChangestoPrivilegedAccountPermissions.yaml",
      "queryFrequency": "PT2H",
      "query": "let AdminRecords = AuditLogs\n| where Category =~ \"RoleManagement\"\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend TargetUserPrincipalName = tostring(TargetResource.userPrincipalName),\n               props = TargetResource.modifiedProperties\n  )\n| mv-apply Property = props on \n  (\n      where Property.displayName =~ \"Role.DisplayName\"\n      | extend RoleName = trim('\"',tostring(Property.newValue))\n  )\n| where RoleName contains \"Admin\";\nAdminRecords\n| summarize dcount(TargetUserPrincipalName) by bin(TimeGenerated, 1h)\n| where dcount_TargetUserPrincipalName > 9\n| join kind=rightsemi  (\n  AdminRecords\n  | extend TimeWindow = bin(TimeGenerated, 1h)\n) on $left.TimeGenerated == $right.TimeWindow\n| extend InitiatedByUser = iff(isnotempty(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.user.userPrincipalName), \"\")\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend TargetName = tostring(split(TargetUserPrincipalName,'@',0)[0]), TargetUPNSuffix = tostring(split(TargetUserPrincipalName,'@',1)[0])\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "UserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddressFirst"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Attempt to bypass conditional access rule in Microsoft Entra ID",
      "id": "3af9285d-bb98-4a35-ad29-5ea39ba0c628",
      "tactics": [
        "InitialAccess",
        "Persistence"
      ],
      "kind": "Scheduled",
      "description": "'Identifies an attempt to Bypass conditional access rule(s) in Microsoft Entra ID.\nThe ConditionalAccessStatus column value details if there was an attempt to bypass Conditional Access or if the Conditional access rule was not satisfied (ConditionalAccessStatus == 1).\nReferences:\nhttps://docs.microsoft.com/azure/active-directory/conditional-access/overview\nhttps://docs.microsoft.com/azure/active-directory/reports-monitoring/concept-sign-ins\nhttps://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\nConditionalAccessStatus == 0 // Success\nConditionalAccessStatus == 1 // Failure\nConditionalAccessStatus == 2 // Not Applied\nConditionalAccessStatus == 3 // unknown'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "BypassCondAccessRule.yaml",
      "queryFrequency": "PT1D",
      "query": "let threshold = 1; // Modify this threshold value to reduce false positives based on your environment\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where ConditionalAccessStatus == 1 or ConditionalAccessStatus =~ \"failure\"\n| mv-apply CAP = parse_json(ConditionalAccessPolicies) on (\n  project ConditionalAccessPoliciesName = CAP.displayName, result = CAP.result\n  | where result =~ \"failure\"\n)\n| extend DeviceDetail = todynamic(DeviceDetail), Status = todynamic(Status), LocationDetails = todynamic(LocationDetails)\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city), Region = tostring(LocationDetails.countryOrRegion)\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend Status = strcat(StatusCode, \": \", ResultDescription)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), Status = make_list(Status,10), StatusDetails = make_list(StatusDetails,50), IPAddresses = make_list(IPAddress,100), IPAddressCount = dcount(IPAddress), CorrelationIds = make_list(CorrelationId,100), ConditionalAccessPoliciesName = make_list(ConditionalAccessPoliciesName,100)\nby UserPrincipalName, UserId, AppDisplayName, tostring(Browser), tostring(OS), City, State, Region, Type\n| where IPAddressCount > threshold and StatusDetails !has \"MFA successfully completed\"\n| mv-expand IPAddresses, Status, StatusDetails, CorrelationIds\n| extend Status = strcat(Status, \" \", StatusDetails)\n| summarize IPAddresses = make_set(IPAddresses,100), Status = make_set(Status,10), CorrelationIds = make_set(CorrelationIds,100), ConditionalAccessPoliciesName = make_set(ConditionalAccessPoliciesName,100)\nby StartTime, EndTime, UserPrincipalName, UserId, AppDisplayName, tostring(Browser), tostring(OS), City, State, Region, IPAddressCount, Type\n| extend IPAddressFirst = tostring(IPAddresses[0]), Name = tostring(split(UserPrincipalName, \"@\")[0]), UPNSuffix = tostring(split(UserPrincipalName, \"@\")[1])\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt",
      "techniques": [
        "T1078",
        "T1098"
      ],
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Name",
            "columnName": "accountName"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "upnSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT5M",
      "name": "Conditional Access - A Conditional Access app exclusion has changed",
      "id": "0990a481-3bc8-4682-838c-313918dd858c",
      "tactics": "CommandAndControl",
      "kind": "Scheduled",
      "description": "A Conditional Access app exclusion has changed in Entra ID.",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Conditional Access - A Conditional Access app exclusion has changed.yaml",
      "queryFrequency": "PT5M",
      "query": "// A Conditional Access app exclusion has changed.\nAuditLogs\n| where OperationName in (\"Update conditional access policy\")\n| extend excludeApplicationsOld = extractjson(\"$.conditions.applications.excludeApplications\", tostring(TargetResources[0].modifiedProperties[0].oldValue))\n| extend excludeApplicationsNew = extractjson(\"$.conditions.applications.excludeApplications\", tostring(TargetResources[0].modifiedProperties[0].newValue))\n| where excludeApplicationsOld != excludeApplicationsNew\n| extend modifiedBy = tostring(InitiatedBy.user.userPrincipalName)\n| extend accountName = tostring(split(modifiedBy, \"@\")[0])\n| extend upnSuffix = tostring(split(modifiedBy, \"@\")[1])\n| project\n    TimeGenerated,\n    OperationName,\n    policy = TargetResources[0].displayName,\n    modifiedBy,\n    accountName,\n    upnSuffix,\n    result = Result,\n    excludeApplicationsOld,\n    excludeApplicationsNew\n| order by TimeGenerated desc",
      "techniques": "T1071",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Name",
            "columnName": "accountName"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "upnSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT5M",
      "name": "Conditional Access - A Conditional Access Device platforms condition has changed (the Device platforms condition can be spoofed)",
      "id": "e3368079-a2c0-4f1c-9fb7-287e907393ef",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "A Conditional Access Device platforms condition has changed (the Device platforms condition can be spoofed) in Entra ID.",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Conditional Access - A Conditional Access Device platforms condition has changed (the Device platforms condition can be spoofed).yaml",
      "queryFrequency": "PT5M",
      "query": "// A Conditional Access Device platforms condition has changed (the Device platforms condition can be spoofed).\nAuditLogs\n| where OperationName in (\"Update conditional access policy\")\n| extend excludePlatformsOld = extractjson(\"$.conditions.platforms.excludePlatforms\", tostring(TargetResources[0].modifiedProperties[0].oldValue))\n| extend excludePlatformsNew = extractjson(\"$.conditions.platforms.excludePlatforms\", tostring(TargetResources[0].modifiedProperties[0].newValue))\n| where excludePlatformsOld != excludePlatformsNew\n| extend modifiedBy = tostring(InitiatedBy.user.userPrincipalName)\n| extend accountName = tostring(split(modifiedBy, \"@\")[0])\n| extend upnSuffix = tostring(split(modifiedBy, \"@\")[1])\n| project\n    TimeGenerated,\n    OperationName,\n    policy = TargetResources[0].displayName,\n    modifiedBy,\n    accountName,\n    upnSuffix,\n    result = Result,\n    excludePlatformsOld,\n    excludePlatformsNew\n| order by TimeGenerated desc",
      "techniques": "T1562.007",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Name",
            "columnName": "accountName"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "upnSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT5M",
      "name": "Conditional Access - A Conditional Access policy was deleted",
      "id": "2e96fa64-ac4d-4c92-b79e-e9c54b5d8230",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "A Conditional Access policy was deleted from Entra ID.",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Conditional Access - A Conditional Access policy was deleted.yaml",
      "queryFrequency": "PT5M",
      "query": "// A Conditional Access policy was deleted.\nAuditLogs\n| where OperationName in (\"Delete conditional access policy\")\n| extend modifiedBy = tostring(InitiatedBy.user.userPrincipalName)\n| extend accountName = tostring(split(modifiedBy, \"@\")[0])\n| extend upnSuffix = tostring(split(modifiedBy, \"@\")[1])\n| project\n    TimeGenerated,\n    OperationName,\n    policy = TargetResources[0].displayName,\n    modifiedBy,\n    accountName,\n    upnSuffix,\n    result = Result,\n    oldPolicy = TargetResources[0].modifiedProperties[0].oldValue\n| order by TimeGenerated desc",
      "techniques": "T1562.007",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Name",
            "columnName": "accountName"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "upnSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT5M",
      "name": "Conditional Access - A Conditional Access policy was disabled",
      "id": "40702da1-ae8a-4e46-ac1f-9327ca6ef588",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "A Conditional Access policy was disabled in Entra ID.",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Conditional Access - A Conditional Access policy was disabled.yaml",
      "queryFrequency": "PT5M",
      "query": "// A Conditional Access policy was disabled.\nAuditLogs\n| where OperationName in (\"Update conditional access policy\")\n| extend stateOld = extractjson(\"$.state\", tostring(TargetResources[0].modifiedProperties[0].oldValue))\n| extend stateNew = extractjson(\"$.state\", tostring(TargetResources[0].modifiedProperties[0].newValue))\n| where stateOld == \"enabled\" and stateNew == \"disabled\"\n| extend modifiedBy = tostring(InitiatedBy.user.userPrincipalName)\n| extend accountName = tostring(split(modifiedBy, \"@\")[0])\n| extend upnSuffix = tostring(split(modifiedBy, \"@\")[1])\n| project\n    TimeGenerated,\n    OperationName,\n    policy = TargetResources[0].displayName,\n    modifiedBy,\n    accountName,\n    upnSuffix,\n    result = Result,\n    stateOld,\n    stateNew\n| order by TimeGenerated desc",
      "techniques": "T1562.007",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Name",
            "columnName": "accountName"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "upnSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT5M",
      "name": "Conditional Access - A Conditional Access policy was put into report-only mode",
      "id": "5588de32-73b1-40b9-bddc-4d9e74051859",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "A Conditional Access policy was put into report-only mode in Entra ID.",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Conditional Access - A Conditional Access policy was put into report-only mode.yaml",
      "queryFrequency": "PT5M",
      "query": "// A Conditional Access policy was put into report-only mode.\nAuditLogs\n| where OperationName in (\"Update conditional access policy\")\n| extend stateOld = extractjson(\"$.state\", tostring(TargetResources[0].modifiedProperties[0].oldValue))\n| extend stateNew = extractjson(\"$.state\", tostring(TargetResources[0].modifiedProperties[0].newValue))\n| where stateOld == \"enabled\" and stateNew == \"enabledForReportingButNotEnforced\"\n| extend modifiedBy = tostring(InitiatedBy.user.userPrincipalName)\n| extend accountName = tostring(split(modifiedBy, \"@\")[0])\n| extend upnSuffix = tostring(split(modifiedBy, \"@\")[1])\n| project\n    TimeGenerated,\n    OperationName,\n    policy = TargetResources[0].displayName,\n    modifiedBy,\n    accountName,\n    upnSuffix,\n    result = Result,\n    stateOld,\n    stateNew\n| order by TimeGenerated desc",
      "techniques": "T1562.007",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Name",
            "columnName": "accountName"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "upnSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT5M",
      "name": "Conditional Access - A Conditional Access policy was updated",
      "id": "ccca6b88-a7b6-41c9-9be2-fc3daeb65b26",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "A Conditional Access policy was updated in Entra ID.",
      "severity": "Informational",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Conditional Access - A Conditional Access policy was updated.yaml",
      "queryFrequency": "PT5M",
      "query": "// A Conditional Access policy was updated.\nAuditLogs\n| where OperationName == \"Update conditional access policy\"\n| extend\n    policy = tostring(TargetResources[0].displayName),\n    modifiedBy = tostring(InitiatedBy.user.userPrincipalName),\n    oldPolicy = tostring(TargetResources[0].modifiedProperties[0].oldValue),\n    newPolicy = tostring(TargetResources[0].modifiedProperties[0].newValue)\n| extend\n    accountName = tostring(split(modifiedBy, \"@\")[0]),\n    upnSuffix = tostring(split(modifiedBy, \"@\")[1])\n| project\n    TimeGenerated,\n    OperationName,\n    policy,\n    modifiedBy,\n    accountName,\n    upnSuffix,\n    oldPolicy,\n    newPolicy,\n    Result",
      "techniques": "T1562",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Name",
            "columnName": "accountName"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "upnSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT5M",
      "name": "Conditional Access - A Conditional Access user/group/role exclusion has changed",
      "id": "2ce7f00d-3b3c-41b9-ae9a-b79c19d2394e",
      "tactics": [
        "Persistence",
        "DefenseEvasion",
        "CredentialAccess"
      ],
      "kind": "Scheduled",
      "description": "A Conditional Access user/group/role exclusion has changed in Azure AD.",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Conditional Access - A Conditional Access usergrouprole exclusion has changed.yaml",
      "queryFrequency": "PT5M",
      "query": "// A Conditional Access user/group/role exclusion has changed.\nAuditLogs\n| where OperationName in (\"Update conditional access policy\")\n| extend excludeUsersOld = extractjson(\"$.conditions.users.excludeUsers\", tostring(TargetResources[0].modifiedProperties[0].oldValue))\n| extend excludeGroupsOld = extractjson(\"$.conditions.users.excludeGroups\", tostring(TargetResources[0].modifiedProperties[0].oldValue))\n| extend excludeRolesOld = extractjson(\"$.conditions.users.excludeRoles\", tostring(TargetResources[0].modifiedProperties[0].oldValue))\n| extend excludeUsersNew = extractjson(\"$.conditions.users.excludeUsers\", tostring(TargetResources[0].modifiedProperties[0].newValue))\n| extend excludeGroupsNew = extractjson(\"$.conditions.users.excludeGroups\", tostring(TargetResources[0].modifiedProperties[0].newValue))\n| extend excludeRolesNew = extractjson(\"$.conditions.users.excludeRoles\", tostring(TargetResources[0].modifiedProperties[0].newValue))\n| where excludeUsersOld != excludeUsersNew or excludeGroupsOld != excludeGroupsNew or excludeRolesOld != excludeRolesNew\n| extend modifiedBy = tostring(InitiatedBy.user.userPrincipalName)\n| extend accountName = tostring(split(modifiedBy, \"@\")[0])\n| extend upnSuffix = tostring(split(modifiedBy, \"@\")[1])\n| project TimeGenerated, OperationName, policy = TargetResources[0].displayName, modifiedBy, accountName, upnSuffix, result = Result,\n          excludeUsersOld, excludeUsersNew, excludeGroupsOld, excludeGroupsNew, excludeRolesOld, excludeRolesNew\n| order by TimeGenerated desc",
      "techniques": [
        "T1098",
        "T1078"
      ],
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Name",
            "columnName": "accountName"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "upnSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT5M",
      "name": "Conditional Access - A new Conditional Access policy was created",
      "id": "0459a1b5-909d-4783-9e27-24536b05a47f",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "A new Conditional Access policy was created in Entra ID.",
      "severity": "Informational",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Conditional Access - A new Conditional Access policy was created.yaml",
      "queryFrequency": "PT5M",
      "query": "// A new Conditional Access policy was created.\nAuditLogs\n| where OperationName in (\"Add conditional access policy\")\n| extend modifiedBy = tostring(InitiatedBy.user.userPrincipalName)\n| extend accountName = tostring(split(modifiedBy, \"@\")[0])\n| extend upnSuffix = tostring(split(modifiedBy, \"@\")[1])\n| project\n    TimeGenerated,\n    OperationName,\n    policy = TargetResources[0].displayName,\n    modifiedBy,\n    accountName,\n    upnSuffix,\n    result = Result,\n    newPolicy = TargetResources[0].modifiedProperties[0].newValue\n| order by TimeGenerated desc",
      "techniques": "T1562.007",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Name",
            "columnName": "accountName"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "upnSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT5M",
      "name": "Conditional Access - Dynamic Group Exclusion Changes",
      "id": "c385944b-17b9-4b2b-921e-0e8d0341a675",
      "tactics": "PrivilegeEscalation",
      "kind": "Scheduled",
      "description": "// Detects changes to Dynamic Membership Rules for specified groups (often used in CA exclusions)",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Conditional Access - Dynamic Group Exclusion Changes.yaml",
      "queryFrequency": "PT5M",
      "query": "// Detects changes to Dynamic Membership Rules for specified groups (often used in CA exclusions)\nlet monitoredGroups = dynamic([\"Group1\", \"Group2\"]);  // <-- Customize this list\nAuditLogs\n| where OperationName == \"Update group\"\n| where AdditionalDetails[0].value == \"DynamicMembership\"\n| extend DynamicGroupName = tostring(TargetResources[0].displayName)\n| where DynamicGroupName in (monitoredGroups)\n| extend modifiedBy = tostring(InitiatedBy.user.userPrincipalName)\n| extend accountName = tostring(split(modifiedBy, \"@\")[0])\n| extend upnSuffix = tostring(split(modifiedBy, \"@\")[1])\n| extend oldRule = tostring(TargetResources[0].modifiedProperties[0].oldValue)\n| extend newRule = tostring(TargetResources[0].modifiedProperties[0].newValue)\n| where oldRule != newRule\n| project\n    TimeGenerated,\n    OperationName,\n    DynamicGroupName,\n    modifiedBy,\n    accountName,\n    upnSuffix,\n    result = Result,\n    oldRule,\n    newRule\n| order by TimeGenerated desc",
      "techniques": "T1484",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "AadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT7D",
      "name": "Suspicious number of resource creation or deployment activities",
      "id": "361dd1e3-1c11-491e-82a3-bb2e44ac36ba",
      "tactics": "Impact",
      "kind": "Scheduled",
      "description": "'Indicates when an anomalous number of VM creations or deployment activities occur in Azure via the AzureActivity log. This query generates the baseline pattern of cloud resource creation by an individual and generates an anomaly when any unusual spike is detected. These anomalies from unusual or privileged users could be an indication of a cloud infrastructure takedown by an adversary.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Creating_Anomalous_Number_Of_Resources_detection.yaml",
      "queryFrequency": "PT1D",
      "query": "let szOperationNames = dynamic([\"microsoft.compute/virtualMachines/write\", \"microsoft.resources/deployments/write\"]);\nlet starttime = 7d;\nlet endtime = 1d;\nlet timeframe = 1d;\nlet TimeSeriesData =\nAzureActivity\n| where TimeGenerated between (startofday(ago(starttime)) .. startofday(now()))\n| where OperationNameValue in~ (szOperationNames)\n| project TimeGenerated, Caller \n| make-series Total = count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by Caller; \nTimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 3, -1, 'linefit')\n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long) \n| where TimeGenerated >= startofday(ago(endtime))\n| where anomalies > 0 and baseline > 0\n| project Caller, TimeGenerated, Total, baseline, anomalies, score\n| join (AzureActivity\n| where TimeGenerated > startofday(ago(endtime)) \n| where OperationNameValue in~ (szOperationNames)\n| summarize make_set(OperationNameValue,100), make_set(_ResourceId,100), make_set(CallerIpAddress,100) by bin(TimeGenerated, timeframe), Caller\n) on TimeGenerated, Caller\n| mv-expand CallerIpAddress=set_CallerIpAddress\n| project-away Caller1\n| extend Name = iif(Caller has '@',tostring(split(Caller,'@',0)[0]),\"\")\n| extend UPNSuffix = iif(Caller has '@',tostring(split(Caller,'@',1)[0]),\"\")\n| extend AadUserId = iif(Caller !has '@',Caller,\"\")",
      "techniques": "T1496",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "HostName",
              "columnName": "ComputerName"
            }
          ],
          "entityType": "Host"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Creation of expensive computes in Azure",
      "id": "9736e5f1-7b6e-4bfb-a708-e53ff1d182c3",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "'Identifies the creation of large size or expensive VMs (with GPUs or with a large number of virtual CPUs) in Azure.\nAn adversary may create new or update existing virtual machines to evade defenses or use them for cryptomining purposes.\nFor Windows/Linux Vm Sizes, see https://docs.microsoft.com/azure/virtual-machines/windows/sizes \nAzure VM Naming Conventions, see https://docs.microsoft.com/azure/virtual-machines/vm-naming-conventions'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 1,
      "sourceFile": "Creation_of_Expensive_Computes_in_Azure.yaml",
      "queryFrequency": "PT1D",
      "query": "let tokens = dynamic([\"416\",\"208\",\"192\",\"128\",\"120\",\"96\",\"80\",\"72\",\"64\",\"48\",\"44\",\"40\",\"nc12\",\"nc24\",\"nv24\"]);\nlet operationList = dynamic([\"microsoft.compute/virtualmachines/write\", \"microsoft.resources/deployments/write\"]);\nAzureActivity\n| where OperationNameValue in~ (operationList)\n| where ActivityStatusValue startswith \"Accept\"\n| where Properties has 'vmSize'\n| extend parsed_property= parse_json(tostring((parse_json(Properties).responseBody))).properties\n| extend vmSize = tostring((parsed_property.hardwareProfile).vmSize)\n| mv-apply token=tokens to typeof(string) on (where vmSize contains token)\n| extend ComputerName = tostring((parsed_property.osProfile).computerName)\n| project TimeGenerated, OperationNameValue, ActivityStatusValue, Caller, CallerIpAddress, ComputerName, vmSize\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])",
      "techniques": "T1578",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "Consent_InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "Consent_InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "Credential_InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "Credential_InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Consent_InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Consent_AccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "Consent_UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "Consent_InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Credential_InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Credential_AccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "Credential_UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "Credential_InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "Consent_InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "Credential_InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2D",
      "name": "Credential added after admin consented to Application",
      "id": "707494a5-8e44-486b-90f8-155d1797a8eb",
      "tactics": [
        "CredentialAccess",
        "Persistence",
        "PrivilegeEscalation"
      ],
      "kind": "Scheduled",
      "description": "'This query will identify instances where Service Principal credentials were added to an application by one user after the application was granted admin consent rights by another user.\n If a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\n Additional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow.\n For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "CredentialAddedAfterAdminConsent.yaml",
      "queryFrequency": "PT1D",
      "query": "let auditLookbackStart = 2d;\nlet auditLookbackEnd = 1d;\nAuditLogs\n| where TimeGenerated >= ago(auditLookbackStart)\n| where OperationName =~ \"Consent to application\" \n| where Result =~ \"success\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend targetResourceName = tostring(TargetResource.displayName),\n               targetResourceID = tostring(TargetResource.id),\n               targetResourceType = tostring(TargetResource.type),\n               targetModifiedProp = TargetResource.modifiedProperties\n  )\n| mv-apply Property = targetModifiedProp on \n  (\n      where Property.displayName =~ \"ConsentContext.IsAdminConsent\"\n      | extend isAdminConsent = trim(@'\"',tostring(Property.newValue))\n  )\n| mv-apply Property = targetModifiedProp on \n  (\n      where Property.displayName =~ \"ConsentAction.Permissions\"\n      | extend Consent_TargetPermissions = trim(@'\"',tostring(Property.newValue))\n  )\n| mv-apply Property = targetModifiedProp on \n  (\n      where Property.displayName =~ \"TargetId.ServicePrincipalNames\"\n      | extend Consent_TargetServicePrincipalNames = tostring(extract_all(@\"([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})\",trim(@'\"',tostring(Property.newValue)))[0])\n  )\n| extend Consent_InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend Consent_InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend Consent_InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend Consent_InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend Consent_InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend Consent_InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| join kind=inner ( \nAuditLogs\n| where TimeGenerated  >= ago(auditLookbackEnd)\n| where OperationName =~ \"Add service principal credentials\"\n| where Result =~ \"success\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend targetResourceName = tostring(TargetResource.displayName),\n               targetResourceID = tostring(TargetResource.id),\n               targetModifiedProp = TargetResource.modifiedProperties\n  )\n| mv-apply Property = targetModifiedProp on \n  (\n      where Property.displayName =~ \"KeyDescription\"\n      | extend Credential_TargetKeyDescription = trim(@'\"',tostring(Property.newValue))\n  )\n| mv-apply Property = targetModifiedProp on \n  (\n      where Property.displayName =~ \"Included Updated Properties\"\n      | extend UpdatedProperties = trim(@'\"',tostring(Property.newValue))\n  )\n| mv-apply Property = targetModifiedProp on \n  (\n      where Property.displayName =~ \"TargetId.ServicePrincipalNames\"\n      | extend Credential_TargetServicePrincipalNames = tostring(extract_all(@\"([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})\",trim(@'\"',tostring(Property.newValue)))[0])\n  )\n| extend Credential_InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend Credential_InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend Credential_InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend Credential_InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend Credential_InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend Credential_InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n) on targetResourceName, targetResourceID\n| extend TimeConsent = TimeGenerated, TimeCred = TimeGenerated1\n| where TimeConsent < TimeCred \n| project TimeConsent, TimeCred, targetResourceName, targetResourceType, isAdminConsent, \nConsent_InitiatingUserOrApp, Consent_TargetServicePrincipalNames, Consent_TargetPermissions,\nConsent_InitiatingAppName, Consent_InitiatingAppServicePrincipalId, Consent_InitiatingUserPrincipalName, Consent_InitiatingAadUserId, Consent_InitiatingIpAddress,\nCredential_InitiatingUserOrApp, Credential_TargetServicePrincipalNames, Credential_TargetKeyDescription,\nCredential_InitiatingAppName, Credential_InitiatingAppServicePrincipalId, Credential_InitiatingUserPrincipalName, Credential_InitiatingAadUserId, Credential_InitiatingIpAddress\n| extend Consent_AccountName = tostring(split(Consent_InitiatingUserPrincipalName, \"@\")[0]), Consent_UPNSuffix = tostring(split(Consent_InitiatingUserPrincipalName, \"@\")[1])\n| extend Credential_AccountName = tostring(split(Credential_InitiatingUserPrincipalName, \"@\")[0]), Credential_UPNSuffix = tostring(split(Credential_InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1555",
        "T1098"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2D",
      "name": "Cross-tenant Access Settings Organization Added",
      "id": "757e6a79-6d23-4ae6-9845-4dac170656b5",
      "tactics": [
        "InitialAccess",
        "Persistence",
        "Discovery"
      ],
      "kind": "Scheduled",
      "description": "'Organizations are added in the Cross-tenant Access Settings to control communication inbound or outbound for users and applications. This detection notifies when an Organization is added other than the list that is supposed to exist from the Microsoft Entra ID Cross-tenant Access Settings.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Cross-tenantAccessSettingsOrganizationAdded.yaml",
      "queryFrequency": "PT2D",
      "query": "// Tenants IDs can be found by navigating to Azure Active Directory then from menu on the left, select External Identities, then from menu on the left, select Cross-tenant access settings and from the list shown of Tenants\nlet ExpectedTenantIDs = dynamic([\"List of expected tenant IDs\",\"Tenant ID 2\"]);\nAuditLogs\n| where OperationName has \"Add a partner to cross-tenant access setting\"\n| mv-apply TargetResource = TargetResources on\n  (\n      where TargetResource.type =~ \"Policy\"\n      | extend Properties = TargetResource.modifiedProperties\n  )\n| mv-apply Property = Properties on\n  (\n      where Property.displayName =~ \"tenantId\"\n      | extend ExtTenantIDAdded = trim('\"',tostring(Property.newValue))\n  )\n| where ExtTenantIDAdded !in (ExpectedTenantIDs)\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1078.004",
        "T1136.003",
        "T1087.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2D",
      "name": "Cross-tenant Access Settings Organization Deleted",
      "id": "eb8a9c1c-f532-4630-817c-1ecd8a60ed80",
      "tactics": [
        "InitialAccess",
        "Persistence",
        "Discovery"
      ],
      "kind": "Scheduled",
      "description": "'Organizations are added in the Cross-tenant Access Settings to control communication inbound or outbound for users and applications. This detection notifies when an Organization is deleted from the Microsoft Entra ID Cross-tenant Access Settings.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Cross-tenantAccessSettingsOrganizationDeleted.yaml",
      "queryFrequency": "PT2D",
      "query": "AuditLogs\n| where OperationName has \"Delete partner specific cross-tenant access setting\"\n| mv-apply TargetResource = TargetResources on\n  (\n      where TargetResource.type =~ \"Policy\"\n      | extend Properties = TargetResource.modifiedProperties\n  )\n| mv-apply Property = Properties on\n  (\n      where Property.displayName =~ \"tenantId\"\n      | extend ExtTenantDeleted = trim('\"',tostring(Property.oldValue))\n  )\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1078.004",
        "T1136.003",
        "T1087.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2D",
      "name": "Cross-tenant Access Settings Organization Inbound Collaboration Settings Changed",
      "id": "c895c5b9-0fc6-40ce-9830-e8818862f2d5",
      "tactics": [
        "InitialAccess",
        "Persistence",
        "Discovery"
      ],
      "kind": "Scheduled",
      "description": "'Organizations are added in the Cross-tenant Access Settings to control communication inbound or outbound for users and applications. This detection notifies when Organization Inbound Collaboration Settings are changed for \"Users & Groups\" and for \"Applications\".'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Cross-tenantAccessSettingsOrganizationInboundCollaborationSettingsChanged.yaml",
      "queryFrequency": "PT2D",
      "query": "// In User & Groups and in Applications, the following \"AccessType\" values in columns PremodifiedInboundSettings and ModifiedInboundSettings are interpreted accordingly\n// When Access Type in premodified inbound settings value was 1 that means that the initial access was allowed. When Access Type in premodified inbound settings value was 2 that means that the initial access was blocked.\n// When Access Type in modified inbound settings value is 1 that means that now access is allowed. When Access Type in modified inbound settings value is 2 that means that now access is blocked.\nAuditLogs\n| where OperationName has \"Update a partner cross-tenant access setting\"\n| mv-apply TargetResource = TargetResources on\n  (\n      where TargetResource.type =~ \"Policy\"\n      | extend Properties = TargetResource.modifiedProperties\n  )\n| mv-apply Property = Properties on\n  (\n      where Property.displayName =~ \"b2bCollaborationInbound\"\n      | extend PremodifiedInboundSettings = trim('\"',tostring(Property.oldValue)),\n               ModifiedInboundSettings = trim(@'\"',tostring(Property.newValue))\n  )\n| where PremodifiedInboundSettings != ModifiedInboundSettings\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1078.004",
        "T1136.003",
        "T1087.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2D",
      "name": "Cross-tenant Access Settings Organization Inbound Direct Settings Changed",
      "id": "276d5190-38de-4eb2-9933-b3b72f4a5737",
      "tactics": [
        "InitialAccess",
        "Persistence",
        "Discovery"
      ],
      "kind": "Scheduled",
      "description": "'Organizations are added in the Cross-tenant Access Settings to control communication inbound or outbound for users and applications. This detection notifies when Organization Inbound Direct Settings are changed for \"Users & Groups\" and for \"Applications\".'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Cross-tenantAccessSettingsOrganizationInboundDirectSettingsChanged.yaml",
      "queryFrequency": "PT2D",
      "query": "// In User & Groups and in Applications, the following \"AccessType\" values in columns PremodifiedInboundSettings and ModifiedInboundSettings are interpreted accordingly\n// When Access Type in premodified inbound settings value was 1 that means that the initial access was allowed. When Access Type in premodified inbound settings value was 2 that means that the initial access was blocked.\n// When Access Type in modified inbound settings value is 1 that means that now access is allowed. When Access Type in modified inbound settings value is 2 that means that now access is blocked.\nAuditLogs\n| where OperationName has \"Update a partner cross-tenant access setting\"\n| mv-apply TargetResource = TargetResources on\n  (\n      where TargetResource.type =~ \"Policy\"\n      | extend Properties = TargetResource.modifiedProperties\n  )\n| mv-apply Property = Properties on\n  (\n      where Property.displayName =~ \"b2bDirectConnectInbound\"\n      | extend PremodifiedInboundSettings = trim('\"',tostring(Property.oldValue)),\n               ModifiedInboundSettings = trim(@'\"',tostring(Property.newValue))\n  )\n| where PremodifiedInboundSettings != ModifiedInboundSettings\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1078.004",
        "T1136.003",
        "T1087.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2D",
      "name": "Cross-tenant Access Settings Organization Outbound Collaboration Settings Changed",
      "id": "229f71ba-d83b-42a5-b83b-11a641049ed1",
      "tactics": [
        "InitialAccess",
        "Persistence",
        "Discovery"
      ],
      "kind": "Scheduled",
      "description": "'Organizations are added in the Cross-tenant Access Settings to control communication inbound or outbound for users and applications. This detection notifies when Organization Outbound Collaboration Settings are changed for \"Users & Groups\" and for \"Applications\".'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Cross-tenantAccessSettingsOrganizationOutboundCollaborationSettingsChanged.yaml",
      "queryFrequency": "PT2D",
      "query": "// In User & Groups and in Applications, the following \"AccessType\" values in columns PremodifiedOutboundSettings and ModifiedOutboundSettings are interpreted accordingly\n// When Access Type in premodified outbound settings value was 1 that means that the initial access was allowed. When Access Type in premodified outbound settings value was 2 that means that the initial access was blocked.\n// When Access Type in modified outbound settings value is 1 that means that now access is allowed. When Access Type in modified outbound settings value is 2 that means that now access is blocked.\nAuditLogs\n| where OperationName has \"Update a partner cross-tenant access setting\"\n| mv-apply TargetResource = TargetResources on\n  (\n      where TargetResource.type =~ \"Policy\"\n      | extend Properties = TargetResource.modifiedProperties\n  )\n| mv-apply Property = Properties on\n  (\n      where Property.displayName =~ \"b2bCollaborationOutbound\"\n      | extend PremodifiedOutboundSettings = trim('\"',tostring(Property.oldValue)),\n               ModifiedOutboundSettings = trim(@'\"',tostring(Property.newValue))\n  )\n| where PremodifiedOutboundSettings != ModifiedOutboundSettings\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1078.004",
        "T1136.003",
        "T1087.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatingAccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatingAccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2D",
      "name": "Cross-tenant Access Settings Organization Outbound Direct Settings Changed",
      "id": "0101e08d-99cd-4a97-a9e0-27649c4369ad",
      "tactics": [
        "InitialAccess",
        "Persistence",
        "Discovery"
      ],
      "kind": "Scheduled",
      "description": "'Organizations are added in the Cross-tenant Access Settings to control communication inbound or outbound for users and applications. This detection notifies when Organization Outbound Direct Settings are changed for \"Users & Groups\" and for \"Applications\".'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Cross-tenantAccessSettingsOrganizationOutboundDirectSettingsChanged.yaml",
      "queryFrequency": "PT2D",
      "query": "// In User & Groups and in Applications, the following \"AccessType\" values in columns PremodifiedOutboundSettings and ModifiedOutboundSettings are interpreted accordingly\n// When Access Type in premodified outbound settings value was 1 that means that the initial access was allowed. When Access Type in premodified outbound settings value was 2 that means that the initial access was blocked.\n// When Access Type in modified outbound settings value is 1 that means that now access is allowed. When Access Type in modified outbound settings value is 2 that means that now access is blocked.\nAuditLogs\n| where OperationName has \"Update a partner cross-tenant access setting\"\n| mv-apply TargetResource = TargetResources on\n  (\n      where TargetResource.type =~ \"Policy\"\n      | extend Properties = TargetResource.modifiedProperties\n  )\n| mv-apply Property = Properties on\n  (\n      where Property.displayName =~ \"b2bDirectConnectOutbound\"\n      | extend PremodifiedOutboundSettings = trim('\"',tostring(Property.oldValue)),\n               ModifiedOutboundSettings = trim(@'\"',tostring(Property.newValue))\n  )\n| where PremodifiedOutboundSettings != ModifiedOutboundSettings\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend InitiatingAccountName = tostring(split(InitiatingUserPrincipalName, \"@\")[0]), InitiatingAccountUPNSuffix = tostring(split(InitiatingUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1078.004",
        "T1136.003",
        "T1087.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "ResourceId",
              "columnName": "_ResourceId"
            }
          ],
          "entityType": "AzureResource"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT15M",
      "name": "Default route (0.0.0.0/0) to Internet or virtual appliance added",
      "id": "5c4f7a1a-7b0e-4d4e-9b41-6f5a6c21e1a7",
      "tactics": [
        "Exfiltration",
        "Impact"
      ],
      "kind": "Scheduled",
      "description": "'Detects creation or update of a route table route that sends default traffic (0.0.0.0/0 or ::/0) to the Internet or a virtual appliance. This can enable unexpected outbound paths, traffic interception, or data exfiltration via an attacker-controlled next hop.'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "DefaultRouteToInternetOrNVAAdded.yaml",
      "queryFrequency": "PT15M",
      "query": "let queryFrequency = 15m;\nAzureActivity\n| where ingestion_time() > ago(queryFrequency)\n| where ActivityStatusValue =~ \"Success\"\n| where tolower(OperationNameValue) has \"microsoft.network/routetables\" and tolower(OperationNameValue) endswith \"/routes/write\"\n| extend requestBody = tostring(parse_json(Properties).requestbody)\n| extend request = parse_json(requestBody)\n| extend routeProps = coalesce(request.properties, request.Properties)\n| extend AddressPrefix = tostring(routeProps.addressPrefix)\n| extend NextHopType = tostring(routeProps.nextHopType)\n| extend NextHopIpAddress = tostring(routeProps.nextHopIpAddress)\n| where AddressPrefix in~ (\"0.0.0.0/0\", \"::/0\")\n| where NextHopType in~ (\"Internet\", \"VirtualAppliance\")\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])\n| project\n    TimeGenerated,\n    Caller,\n    Name,\n    UPNSuffix,\n    CallerIpAddress,\n    OperationNameValue,\n    ResourceGroup,\n    _ResourceId,\n    Resource,\n    CorrelationId,\n    AddressPrefix,\n    NextHopType,\n    NextHopIpAddress",
      "techniques": "T1567",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Attempts to sign in to disabled accounts",
      "id": "75ea5c39-93e5-489b-b1e1-68fa6c9d2d04",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "'Identifies failed attempts to sign in to disabled accounts across multiple Azure Applications.\nDefault threshold for Azure Applications attempted to sign in to is 3.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n50057 - User account is disabled. The account has been disabled by an administrator.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "DisabledAccountSigninsAcrossManyApplications.yaml",
      "queryFrequency": "PT1D",
      "query": "let threshold = 3;\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where ResultType == \"50057\"\n| where ResultDescription =~ \"User account is disabled. The account has been disabled by an administrator.\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), applicationCount = dcount(AppDisplayName),\napplicationSet = make_set(AppDisplayName), count() by UserPrincipalName, IPAddress, Type\n| where applicationCount >= threshold\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt",
      "techniques": "T1078",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "FullName",
            "columnName": "UserPrincipalName"
          },
          {
            "identifier": "Name",
            "columnName": "Name"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "UPNSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT1D",
      "name": "Distributed Password cracking attempts in Microsoft Entra ID",
      "id": "bfb1c90f-8006-4325-98be-c7fffbc254d6",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'Identifies distributed password cracking attempts from the Microsoft Entra ID SigninLogs.\nThe query looks for unusually high number of failed password attempts coming from multiple locations for a user account.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n50053   Account is locked because the user tried to sign in too many times with an incorrect user ID or password.\n50055   Invalid password, entered expired password.\n50056   Invalid or null password - Password does not exist in store for this user.\n50126   Invalid username or password, or invalid on-premises username or password.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "DistribPassCrackAttempt.yaml",
      "queryFrequency": "PT1D",
      "query": "let s_threshold = 30;\nlet l_threshold = 3;\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where OperationName =~ \"Sign-in activity\"\n// Error codes that we want to look at as they are related to the use of incorrect password.\n| where ResultType in (\"50126\", \"50053\" , \"50055\", \"50056\")\n| extend DeviceDetail = todynamic(DeviceDetail), Status = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend LocationString = strcat(tostring(LocationDetails.countryOrRegion), \"/\", tostring(LocationDetails.state), \"/\", tostring(LocationDetails.city))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), LocationCount=dcount(LocationString), Location = make_set(LocationString,100),\nIPAddress = make_set(IPAddress,100), IPAddressCount = dcount(IPAddress), AppDisplayName = make_set(AppDisplayName,100), ResultDescription = make_set(ResultDescription,50),\nBrowser = make_set(Browser,20), OS = make_set(OS,20), SigninCount = count() by UserPrincipalName, Type\n// Setting a generic threshold - Can be different for different environment\n| where SigninCount > s_threshold and LocationCount >= l_threshold\n| extend Location = tostring(Location), IPAddress = tostring(IPAddress), AppDisplayName = tostring(AppDisplayName), ResultDescription = tostring(ResultDescription), Browser = tostring(Browser), OS = tostring(OS)\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "full_access_as_app Granted To Application",
      "id": "54e22fed-0ec6-4fb2-8312-2a3809a93f63",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "'This detection looks for the full_access_as_app permission being granted to an OAuth application with Admin Consent.\nThis permission provide access to all Exchange mailboxes via the EWS API can could be exploited to access sensitive data by being added to a compromised application. The application granted this permission should be reviewed to ensure that it is absolutely necessary for the applications function.\nRef: https://learn.microsoft.com/graph/auth-limit-mailbox-access'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "ExchangeFullAccessGrantedToApp.yaml",
      "queryFrequency": "PT1H",
      "query": "AuditLogs\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"full_access_as_app\"\n| mv-expand TargetResources\n| extend OAuthAppName = TargetResources.displayName\n| extend ModifiedProperties = TargetResources.modifiedProperties \n| mv-apply Property = ModifiedProperties on \n  (\n      where Property.displayName =~ \"ConsentContext.isAdminConsent\"\n      | extend AdminConsent = tostring(Property.newValue)\n  )\n| mv-apply Property = ModifiedProperties on \n  (\n      where Property.displayName =~ \"ConsentAction.Permissions\"\n      | extend Permissions = tostring(Property.newValue)\n  )\n| mv-apply Property = ModifiedProperties on \n  (\n      where Property.displayName =~ \"TargetId.ServicePrincipalNames\"\n      | extend AppId = tostring(Property.newValue)\n  )\n| mv-apply Property = AdditionalDetails on \n  (\n      where Property.key =~ \"User-Agent\"\n      | extend InitiatingUserAgent = replace('\"', '', tostring(Property.value))\n  )\n| project-away Property\n| parse Permissions with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \",\" *\n| where GrantScope1 =~ \"full_access_as_app\"\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| project-reorder TimeGenerated, OAuthAppName, AppId, AdminConsent, Permissions, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, InitiatingUserAgent, GrantScope1, GrantConsentType\n| extend GrantInitiatedBy = tostring(iff(isnotempty(InitiatingUserPrincipalName), InitiatingUserPrincipalName, InitiatingAppName))\n| extend Name = split(InitiatingUserPrincipalName, \"@\")[0], UPNSuffix = split(InitiatingUserPrincipalName, \"@\")[1]",
      "techniques": "T1550.001",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "PublicIP"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "ResourceId",
              "columnName": "ResourceId"
            }
          ],
          "entityType": "AzureResource"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "AppDisplayName"
            },
            {
              "identifier": "AppId",
              "columnName": "AppId"
            }
          ],
          "entityType": "CloudApplication"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "[Deprecated] Explicit MFA Deny",
      "id": "a22740ec-fc1e-4c91-8de6-c29c6450ad00",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'User explicitly denies MFA push, indicating that login was not expected and the account's password may be compromised.\nThis rule is deprecated as of July-2024. Alternative rule with similar logic and contex from more data source \nis available at https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20Entra%20ID/Analytic%20Rules/MFARejectedbyUser.yaml'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "ExplicitMFADeny.yaml",
      "queryFrequency": "PT1H",
      "query": "let aadFunc = (tableName: string) {\n    table(tableName)\n    | where ResultType == 500121\n    | where Status has \"MFA Denied; user declined the authentication\" or Status has \"MFA denied; Phone App Reported Fraud\"\n    | extend Type = Type, PublicIP = IPAddress\n    | extend\n        Name = tostring(split(UserPrincipalName, '@', 0)[0]),\n        UPNSuffix = tostring(split(UserPrincipalName, '@', 1)[0])\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet dvcInfo = DeviceInfo\n    | extend SensorHealthState = column_ifexists(\"SensorHealthState\", \"\")\n    | where OnboardingStatus == \"Onboarded\" and SensorHealthState == \"Active\"\n    | project PublicIP, AadDeviceId;\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n| join kind=leftouter dvcInfo on PublicIP",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT7D",
      "name": "Failed login attempts to Azure Portal",
      "id": "223db5c1-1bf8-47d8-8806-bed401b356a4",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'Identifies failed login attempts in the Microsoft Entra ID SigninLogs to the Azure Portal.  Many failed logon attempts or some failed logon attempts from multiple IPs could indicate a potential brute force attack.\nThe following are excluded due to success and non-failure results:\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n0 - successful logon\n50125 - Sign-in was interrupted due to a password reset or password registration entry.\n50140 - This error occurred due to 'Keep me signed in' interrupt when the user was signing-in.'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "FailedLogonToAzurePortal.yaml",
      "queryFrequency": "PT1D",
      "query": "let timeRange = 1d;\nlet lookBack = 7d;\nlet threshold_Failed = 5;\nlet threshold_FailedwithSingleIP = 20;\nlet threshold_IPAddressCount = 2;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet aadFunc = (tableName:string){\nlet azPortalSignins = materialize(table(tableName)\n| where TimeGenerated >= ago(lookBack)\n// Azure Portal only\n| where AppDisplayName =~ \"Azure Portal\")\n;\nlet successPortalSignins = azPortalSignins\n| where TimeGenerated >= ago(timeRange)\n// Azure Portal only and exclude non-failure Result Types\n| where ResultType in (\"0\", \"50125\", \"50140\")\n// Tagging identities not resolved to friendly names\n//| extend Unresolved = iff(Identity matches regex isGUID, true, false)\n| distinct TimeGenerated, UserPrincipalName\n;\nlet failPortalSignins = azPortalSignins\n| where TimeGenerated >= ago(timeRange)\n// Azure Portal only and exclude non-failure Result Types\n| where ResultType !in (\"0\", \"50125\", \"50140\", \"70044\", \"70043\")\n// Tagging identities not resolved to friendly names\n| extend Unresolved = iff(Identity matches regex isGUID, true, false)\n;\n// Verify there is no success for the same connection attempt after the fail\nlet failnoSuccess = failPortalSignins | join kind= leftouter (\n   successPortalSignins\n) on UserPrincipalName\n| where TimeGenerated > TimeGenerated1 or isempty(TimeGenerated1)\n| project-away TimeGenerated1, UserPrincipalName1\n;\n// Lookup up resolved identities from last 7 days\nlet identityLookup = azPortalSignins\n| where TimeGenerated >= ago(lookBack)\n| where not(Identity matches regex isGUID)\n| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;\n// Join resolved names to unresolved list from portal signins\nlet unresolvedNames = failnoSuccess | where Unresolved == true | join kind= inner (\n   identityLookup\n) on UserId\n| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName\n| project-away lu_UserDisplayName, lu_UserPrincipalName;\n// Join Signins that had resolved names with list of unresolved that now have a resolved name\nlet u_azPortalSignins = failnoSuccess | where Unresolved == false | union unresolvedNames;\nu_azPortalSignins\n| extend DeviceDetail = todynamic(DeviceDetail), Status = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n| extend Status = strcat(ResultType, \": \", ResultDescription), OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city), Region = tostring(LocationDetails.countryOrRegion)\n| extend FullLocation = strcat(Region,'|', State, '|', City)  \n| summarize TimeGenerated = make_list(TimeGenerated,100), Status = make_list(Status,100), IPAddresses = make_list(IPAddress,100), IPAddressCount = dcount(IPAddress), FailedLogonCount = count()\nby UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation, Type\n| mvexpand TimeGenerated, IPAddresses, Status\n| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)\n| project-away IPAddresses\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status, FailedLogonCount, IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation, Type\n| where (IPAddressCount >= threshold_IPAddressCount and FailedLogonCount >= threshold_Failed) or FailedLogonCount >= threshold_FailedwithSingleIP\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "targetDisplayName"
            }
          ],
          "entityType": "CloudApplication"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "First access credential added to Application or Service Principal where no credential was present",
      "id": "2cfc3c6e-f424-4b88-9cc9-c89f482d016a",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "'This will alert when an admin or app owner account adds a new credential to an Application or Service Principal where there was no previous verify KeyCredential associated.\nIf a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "FirstAppOrServicePrincipalCredential.yaml",
      "queryFrequency": "PT1H",
      "query": "AuditLogs\n| where OperationName has (\"Certificates and secrets management\")\n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"Application\"\n      | extend targetDisplayName = tostring(TargetResource.displayName),\n               targetId = tostring(TargetResource.id),\n               targetType = tostring(TargetResource.type),\n               keyEvents = TargetResource.modifiedProperties\n  )\n| mv-apply Property = keyEvents on \n  (\n      where Property.displayName =~ \"KeyDescription\"\n      | extend new_value_set = parse_json(tostring(Property.newValue)),\n               old_value_set = parse_json(tostring(Property.oldValue))\n  )\n| where old_value_set == \"[]\"\n| mv-expand new_value_set\n| parse new_value_set with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| where keyUsage =~ \"Verify\"\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend InitiatingUserAgent = tostring(AdditionalDetail.value)\n  )\n| project-away new_value_set, old_value_set, TargetResource, Property, AdditionalDetail\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| project-reorder TimeGenerated, OperationName, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, InitiatingUserAgent, \ntargetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId\n| extend Name = split(InitiatingUserPrincipalName, \"@\")[0], UPNSuffix = split(InitiatingUserPrincipalName, \"@\")[1]",
      "techniques": "T1550.001",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "Suspicious granting of permissions to an account",
      "id": "b2c15736-b9eb-4dae-8b02-3016b6a45a32",
      "tactics": [
        "Persistence",
        "PrivilegeEscalation"
      ],
      "kind": "Scheduled",
      "description": "'Identifies IPs from which users grant access to other users on Azure resources and alerts when a previously unseen source IP address is used.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Granting_Permissions_To_Account_detection.yaml",
      "queryFrequency": "PT1D",
      "query": "let starttime = 14d;\nlet endtime = 1d;\n// The number of operations above which an IP address is considered an unusual source of role assignment operations\nlet alertOperationThreshold = 5;\nlet AzureBuiltInRole = externaldata(Role:string,RoleDescription:string,ID:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/AzureBuiltInRole.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet createRoleAssignmentActivity = AzureActivity\n| where OperationNameValue =~ \"microsoft.authorization/roleassignments/write\";\nlet RoleAssignedActivity = createRoleAssignmentActivity \n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| summarize count() by CallerIpAddress, Caller, bin(TimeGenerated, 1d)\n| where count_ >= alertOperationThreshold\n// Returns all the records from the right side that don't have matches from the left.\n| join kind = rightanti ( \ncreateRoleAssignmentActivity\n| where TimeGenerated > ago(endtime)\n| extend parsed_property = tostring(parse_json(Properties).requestbody)\n| extend PrincipalId = case(parsed_property has_cs 'PrincipalId',parse_json(parsed_property).Properties.PrincipalId, parsed_property has_cs 'principalId',parse_json(parsed_property).properties.principalId,\"\")\n| extend PrincipalType = case(parsed_property has_cs 'PrincipalType',parse_json(parsed_property).Properties.PrincipalType, parsed_property has_cs 'principalType',parse_json(parsed_property).properties.principalType, \"\")\n| extend Scope = case(parsed_property has_cs 'Scope',parse_json(parsed_property).Properties.Scope, parsed_property has_cs 'scope',parse_json(parsed_property).properties.scope,\"\")\n| extend RoleAddedDetails = case(parsed_property has_cs 'RoleDefinitionId',parse_json(parsed_property).Properties.RoleDefinitionId,parsed_property has_cs 'roleDefinitionId',parse_json(parsed_property).properties.roleDefinitionId,\"\")\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = make_set(TimeGenerated), ActivityStatusValue = make_set(ActivityStatusValue), CorrelationId = make_set(CorrelationId), ActivityCountByCallerIPAddress = count()  \nby ResourceId, CallerIpAddress, Caller, OperationNameValue, Resource, ResourceGroup, PrincipalId, PrincipalType, Scope, RoleAddedDetails\n) on CallerIpAddress, Caller\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress;\nlet RoleAssignedActivitywithRoleDetails = RoleAssignedActivity\n| extend RoleAssignedID = tostring(split(RoleAddedDetails, \"/\")[-1])\n// Returns all matching records from left and right sides.\n| join kind = inner (AzureBuiltInRole \n) on $left.RoleAssignedID == $right.ID;\nlet CallerIPCountSummary = RoleAssignedActivitywithRoleDetails | summarize AssignmentCountbyCaller = count() by Caller, CallerIpAddress;\nlet RoleAssignedActivityWithCount = RoleAssignedActivitywithRoleDetails | join kind = inner (CallerIPCountSummary | project Caller, AssignmentCountbyCaller, CallerIpAddress) on Caller, CallerIpAddress;\nRoleAssignedActivityWithCount\n| summarize arg_max(StartTimeUtc, *) by PrincipalId, RoleAssignedID\n// \tReturns all the records from the left side and only matching records from the right side.\n| join kind = leftouter( IdentityInfo\n| summarize arg_max(TimeGenerated, *) by AccountObjectId\n) on $left.PrincipalId == $right.AccountObjectId\n// Check if assignment count is greater than the threshold.\n| where AssignmentCountbyCaller >= alertOperationThreshold\n| project ActivityTimeStamp, OperationNameValue, Caller, CallerIpAddress, PrincipalId, RoleAssignedID, RoleAddedDetails, Role, RoleDescription, AccountUPN, AccountCreationTime, GroupMembership, UserType, ActivityStatusValue, ResourceGroup, PrincipalType, Scope, CorrelationId, timestamp, AccountCustomEntity, IPCustomEntity, AssignmentCountbyCaller\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])",
      "techniques": [
        "T1098",
        "T1548"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InvitedUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InvitedUserName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InvitedUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "DistinguishedName",
              "columnName": "AADGroup"
            },
            {
              "identifier": "ObjectGuid",
              "columnName": "AADGroupId"
            }
          ],
          "entityType": "SecurityGroup"
        }
      ],
      "queryPeriod": "PT2H",
      "name": "Guest accounts added in Entra ID Groups other than the ones specified",
      "id": "6ab1f7b2-61b8-442f-bc81-96afe7ad8c53",
      "tactics": [
        "InitialAccess",
        "Persistence",
        "Discovery"
      ],
      "kind": "Scheduled",
      "description": "'Guest Accounts are added in the Organization Tenants to perform various tasks i.e projects execution, support etc.. This detection notifies when guest users are added to Microsoft Entra ID Groups other than the ones specified and poses a risk to gain access to sensitive apps or data.'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "GuestAccountsAddedinAADGroupsOtherThanTheOnesSpecified.yaml",
      "queryFrequency": "PT2H",
      "query": "// OBJECT ID of AAD Groups can be found by navigating to Azure Active Directory then from menu on the left, select Groups and from the list shown of AAD Groups, the Second Column shows the ObjectID of each\nlet GroupIDs = dynamic([\"List with Custom AAD GROUP OBJECT ID 1\",\"Custom AAD GROUP OBJECT ID 2\"]);\nAuditLogs\n| where OperationName in ('Add member to group', 'Add owner to group')\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n// Uncomment the following line to filter events where the inviting user was a guest user\n//| where InitiatedBy has_any (\"CUSTOM DOMAIN NAME#\", \"#EXT#\")\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend InvitedUserPrincipalName = trim(@'\"',tostring(TargetResource.userPrincipalName)),\n               Properties = TargetResource.modifiedProperties\n  )\n| mv-apply Property = Properties on \n  (\n      where Property.displayName =~ \"Group.DisplayName\"\n      | extend AADGroup = trim('\"',tostring(Property.newValue))\n  )\n| where InvitedUserPrincipalName has_any (\"CUSTOM DOMAIN NAME#\", \"#EXT#\")\n| mv-apply Property = Properties on\n   (\n     where Property.displayName =~ \"Group.ObjectID\"\n     | extend AADGroupId = trim('\"',tostring(Property.newValue))\n   )\n| project-away TargetResource, Property\n| where AADGroupId !in (GroupIDs)\n| extend Name = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])\n| extend InvitedUserName = tostring(split(InvitedUserPrincipalName,'@',0)[0]), InvitedUPNSuffix = tostring(split(InvitedUserPrincipalName,'@',1)[0])",
      "techniques": [
        "T1078.004",
        "T1136.003",
        "T1087.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "Caller"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "ResourceId",
              "columnName": "_ResourceId"
            }
          ],
          "entityType": "AzureResource"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Azure Machine Learning Write Operations",
      "id": "68c89998-8052-4c80-a1f6-9d81060b6d57",
      "tactics": [
        "InitialAccess",
        "Execution",
        "Impact"
      ],
      "kind": "Scheduled",
      "description": "'Shows the most prevalent users who perform write operations on Azure Machine Learning resources. List the common source IP address for each of those accounts. If an operation is not from those IP addresses, it may be worthy of investigation.'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Machine_Learning_Creation.yaml",
      "queryFrequency": "PT1D",
      "query": "AzureActivity\n| where ResourceProviderValue == \"MICROSOFT.MACHINELEARNINGSERVICES\"  // Filter activities related to Microsoft Machine Learning Services\n| extend SCOPE = tostring(parse_json(Authorization).scope)  // Parse Authorization scope as string\n| extend subname = split(Hierarchy, \"/\")  // Split Hierarchy to extract Subscription Name and ID\n| extend ['Subscription Name'] = subname[-2], ['Subscription ID'] = subname[-1]  // Extract Subscription Name and ID\n| extend Properties = parse_json(Properties)  // Parse Properties as JSON\n| extend Properties_entity = tostring(Properties.entity)  // Cast Properties.entity to string\n| where isnotempty(Properties_entity)  // Filter activities where Properties.entity is not empty\n// | where Properties_entity contains \"deepseek\"  // Filter activities where Properties.entity contains \"deepseek\"\n| where OperationNameValue contains \"write\"  // Filter activities where OperationNameValue contains \"write\"\n| where OperationNameValue !contains \"MICROSOFT.AUTHORIZATION/ROLEASSIGNMENTS/WRITE\"  // Exclude role assignments\n| extend LLM = tostring(split(Properties_entity, \"/\")[-1])  // Extract the last segment of Properties_entity and cast it to string\n| distinct TimeGenerated, tostring(['Subscription Name']), ResourceGroup, tostring(['Subscription ID']), Caller, CallerIpAddress, OperationNameValue, LLM, _ResourceId  // Select distinct relevant fields for output",
      "techniques": [
        "T1078",
        "T1059",
        "T1496"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Mail.Read Permissions Granted to Application",
      "id": "2560515c-07d1-434e-87fb-ebe3af267760",
      "tactics": "Persistence",
      "kind": "Scheduled",
      "description": "'This query look for applications that have been granted (Delegated or App/Role) permissions to Read Mail (Permissions field has Mail.Read) and subsequently has been consented to. This can help identify applications that have been abused to gain access to mailboxes.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "MailPermissionsAddedToApplication.yaml",
      "queryFrequency": "PT1D",
      "query": "AuditLogs\n| where Category =~ \"ApplicationManagement\"\n| where ActivityDisplayName has_any (\"Add delegated permission grant\",\"Add app role assignment to service principal\")  \n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n      | extend props = TargetResource.modifiedProperties,\n               Type = tostring(TargetResource.type),\n               PermissionsAddedTo = tostring(TargetResource.displayName)\n  )\n| mv-apply Property = props on \n  (\n      where Property.displayName =~ \"DelegatedPermissionGrant.Scope\"\n      | extend DisplayName = tostring(Property.displayName), Permissions = trim('\"',tostring(Property.newValue))\n  )\n| where Permissions has_any (\"Mail.Read\", \"Mail.ReadWrite\")\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend InitiatingUserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| project-away props, TargetResource, AdditionalDetail, Property\n| join kind=leftouter(\n  AuditLogs\n  | where ActivityDisplayName has \"Consent to application\"\n  | mv-apply TargetResource = TargetResources on \n      (\n          where TargetResource.type =~ \"ServicePrincipal\"\n          | extend AppName = tostring(TargetResource.displayName),\n                   AppId = tostring(TargetResource.id)\n      )\n| project AppName, AppId, CorrelationId) on CorrelationId\n| project-away CorrelationId1\n| project-reorder TimeGenerated, OperationName, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, InitiatingUserAgent, PermissionsAddedTo, Permissions, AppName, AppId, CorrelationId\n| extend Name = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1098",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "GrantInitiatedByUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "GrantInitiatedByAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "GrantInitiatedByAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "GrantIpAddress"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "AppDisplayName"
            }
          ],
          "entityType": "CloudApplication"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "Suspicious application consent similar to O365 Attack Toolkit",
      "id": "f948a32f-226c-4116-bddd-d95e91d97eb9",
      "tactics": [
        "CredentialAccess",
        "DefenseEvasion"
      ],
      "kind": "Scheduled",
      "description": "'This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the MDSec O365 Attack Toolkit (https://github.com/mdsecactivebreach/o365-attack-toolkit).\nThe default permissions/scope for the MDSec O365 Attack toolkit change sometimes but often include contacts.read, user.read, mail.read, notes.read.all, mailboxsettings.readwrite, files.readwrite.all, mail.send, files.read, and files.read.all.\nConsent to applications with these permissions should be rare, especially as the knownApplications list is expanded, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "MaliciousOAuthApp_O365AttackToolkit.yaml",
      "queryFrequency": "PT1D",
      "query": "let detectionTime = 1d;\nlet joinLookback = 14d;\nlet threshold = 5;\nlet o365_attack_regex = \"contacts.read|user.read|mail.read|notes.read.all|mailboxsettings.readwrite|Files.ReadWrite.All|mail.send|files.read|files.read.all\";\nlet o365_attack = dynamic([\"contacts.read\", \"user.read\", \"mail.read\", \"notes.read.all\", \"mailboxsettings.readwrite\", \"Files.ReadWrite.All\", \"mail.send\", \"files.read\", \"files.read.all\"]);\nAuditLogs\n| where TimeGenerated > ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend AppDisplayName = tostring(TargetResource.displayName),\n               AppClientId = tostring(TargetResource.id),\n               props = TargetResource.modifiedProperties\n  )\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\"))) // NOTE: a MATCH from this list will cause the alert to NOT fire - please modify for your environment!\n| mv-apply ConsentFull = props on \n  (\n      where ConsentFull.displayName =~ \"ConsentAction.Permissions\"\n  )\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \", CreatedDateTime\" * \"]\" *\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| where ConsentFull has_any (o365_attack)  \n| extend GrantScopeCount = countof(tolower(GrantScope1), o365_attack_regex, 'regex')\n| where GrantScopeCount > threshold\n| extend GrantInitiatedByAppName = tostring(InitiatedBy.app.displayName)\n| extend GrantInitiatedByAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend GrantInitiatedByUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend GrantInitiatedByAadUserId = tostring(InitiatedBy.user.id)\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| extend GrantInitiatedBy = iff(isnotempty(GrantInitiatedByUserPrincipalName), GrantInitiatedByUserPrincipalName, GrantInitiatedByAppName)\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend GrantUserAgent = AdditionalDetail.value\n  )\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantInitiatedByUserPrincipalName, GrantInitiatedByAadUserId, GrantInitiatedByAppName, GrantInitiatedByAppServicePrincipalId, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n  | where TimeGenerated > ago(joinLookback)\n  | where LoggedByService =~ \"Core Directory\"\n  | where Category =~ \"ApplicationManagement\"\n  | where OperationName =~ \"Add service principal\"\n  | mv-apply TargetResource = TargetResources on \n      (\n          where TargetResource.type =~ \"ServicePrincipal\"\n          | extend props = TargetResource.modifiedProperties,\n                  AppClientId = tostring(TargetResource.id)\n      )\n  | mv-apply Property = props on \n      (\n          where Property.displayName =~ \"AppAddress\" and Property.newValue has \"AddressType\"\n          | extend AppReplyURLs = trim('\"',tostring(Property.newValue))\n      )\n  | distinct AppClientId, tostring(AppReplyURLs)\n) on AppClientId\n| join kind = innerunique (AuditLogs\n      | where TimeGenerated > ago(joinLookback)\n      | where LoggedByService =~ \"Core Directory\"\n      | where Category =~ \"ApplicationManagement\"\n      | where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n          | mv-apply TargetResource = TargetResources on \n          (\n              where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n              | extend GrantAuthentication = tostring(TargetResource.displayName)\n          )\n      | extend GrantOperation = OperationName\n      | project GrantAuthentication, GrantOperation, CorrelationId\n  ) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantInitiatedByUserPrincipalName, GrantInitiatedByAadUserId, GrantInitiatedByAppName, GrantInitiatedByAppServicePrincipalId, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n| extend Name = tostring(split(GrantInitiatedByUserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(GrantInitiatedByUserPrincipalName,'@',1)[0])",
      "techniques": [
        "T1528",
        "T1550"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "GrantInitiatedByUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "GrantInitiatedByAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "GrantInitiatedByAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "GrantIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "Suspicious application consent similar to PwnAuth",
      "id": "39198934-62a0-4781-8416-a81265c03fd6",
      "tactics": [
        "CredentialAccess",
        "DefenseEvasion"
      ],
      "kind": "Scheduled",
      "description": "'This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the FireEye PwnAuth toolkit (https://github.com/fireeye/PwnAuth).\nThe default permissions/scope for the PwnAuth toolkit are user.read, offline_access, mail.readwrite, mail.send, and files.read.all.\nConsent to applications with these permissions should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "MaliciousOAuthApp_PwnAuth.yaml",
      "queryFrequency": "PT1D",
      "query": "let detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated > ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"offline\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend AppDisplayName = tostring(TargetResource.displayName),\n               AppClientId = tostring(TargetResource.id),\n               props = TargetResource.modifiedProperties\n  )\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| mv-apply ConsentFull = props on \n  (\n      where ConsentFull.displayName =~ \"ConsentAction.Permissions\"\n  )\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull has_all (\"user.read\", \"offline_access\", \"mail.readwrite\", \"mail.send\", \"files.read.all\")\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantInitiatedByAppName = tostring(InitiatedBy.app.displayName)\n| extend GrantInitiatedByAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend GrantInitiatedByUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend GrantInitiatedByAadUserId = tostring(InitiatedBy.user.id)\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| extend GrantInitiatedBy = iff(isnotempty(GrantInitiatedByUserPrincipalName), GrantInitiatedByUserPrincipalName, GrantInitiatedByAppName)\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend GrantUserAgent = AdditionalDetail.value\n  )\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantInitiatedByUserPrincipalName, GrantInitiatedByAadUserId, GrantInitiatedByAppName, GrantInitiatedByAppServicePrincipalId, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n  | mv-apply TargetResource = TargetResources on \n      (\n          where TargetResource.type =~ \"ServicePrincipal\"\n          | extend props = TargetResource.modifiedProperties,\n                  AppClientId = tostring(TargetResource.id)\n      )\n  | mv-apply Property = props on \n      (\n          where Property.displayName =~ \"AppAddress\" and Property.newValue has \"AddressType\"\n          | extend AppReplyURLs = trim('\"',tostring(Property.newValue))\n      )\n| distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n      | mv-apply TargetResource = TargetResources on \n          (\n              where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n              | extend GrantAuthentication = tostring(TargetResource.displayName)\n          )\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantInitiatedByUserPrincipalName, GrantInitiatedByAadUserId, GrantInitiatedByAppName, GrantInitiatedByAppServicePrincipalId, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n| extend timestamp = TimeGenerated, Name = tostring(split(GrantInitiatedByUserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(GrantInitiatedByUserPrincipalName,'@',1)[0])",
      "techniques": [
        "T1528",
        "T1550"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "UserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "FailedIPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "MFA Rejected by User",
      "id": "d99cf5c3-d660-436c-895b-8a8f8448da23",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "'Identifies occurances where a user has rejected an MFA prompt. This could be an indicator that a threat actor has compromised the username and password of this user account and is using it to try and log into the account.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins\nThis query has also been updated to include UEBA logs IdentityInfo and BehaviorAnalytics for contextual information around the results. \nPlease note, MFA Failed logons from known IP ranges can be benign depending on the conditional access policies. In case of noisy behavior, consider tuning the source IP ranges or location filter after careful consideration'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "MFARejectedbyUser.yaml",
      "queryFrequency": "PT1H",
      "query": "let riskScoreCutoff = 3; //Adjust this score threshold based on volume of results. Activities identified as the most abnormal receive the highest scores (on a scale of 0-10)\nSigninLogs\n| where ResultType == 500121\n| extend additionalDetails_ = tostring(Status.additionalDetails)\n| extend UserPrincipalName = tolower(UserPrincipalName)\n| where additionalDetails_ =~ \"MFA denied; user declined the authentication\" or additionalDetails_ has \"fraud\"\n| summarize StartTime = min(TimeGenerated), EndTIme = max(TimeGenerated) by UserPrincipalName, UserId, AADTenantId, FailedIPAddress = IPAddress\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])\n| join kind=leftouter (\n    IdentityInfo\n    | summarize LatestReportTime = arg_max(TimeGenerated, *) by AccountUPN\n    | project AccountUPN, Tags, JobTitle, GroupMembership, AssignedRoles, UserType, IsAccountEnabled\n    | summarize\n        Tags = make_set(Tags, 1000),\n        GroupMembership = make_set(GroupMembership, 1000),\n        AssignedRoles = make_set(AssignedRoles, 1000),\n        UserType = make_set(UserType, 1000),\n        UserAccountControl = make_set(UserType, 1000)\n    by AccountUPN\n    | extend UserPrincipalName=tolower(AccountUPN)\n) on UserPrincipalName\n//Below it will be joined with BehaviorAnalytics table to the Failed IP Addresses\n| join kind=leftouter (\n    BehaviorAnalytics\n    | where ActivityType in (\"FailedLogOn\", \"LogOn\")\n    | where isnotempty(SourceIPAddress)\n    | project UsersInsights, DevicesInsights, ActivityInsights, InvestigationPriority, SourceIPAddress, UserName\n    | project-rename FailedIPAddress = SourceIPAddress, Name = UserName\n    | summarize\n      MaxInvestigationScore = max(InvestigationPriority)  // Only retrieve maximum Investigation Property score for both FailedIP and User\n    by FailedIPAddress, Name)\non FailedIPAddress, Name  // Joining on both IP and User so as to only return context associated with same user\n| extend UEBARiskScore = MaxInvestigationScore\n| project-away *1 // removing duplicate columns post outer join from output\n| where  UEBARiskScore > riskScoreCutoff\n| sort by UEBARiskScore desc",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "MFA Spamming followed by Successful login",
      "id": "a8cc6d5c-4e7e-4b48-b4ac-d8a116c62a8b",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'Identifies MFA Spamming followed by Successful logins and by a successful authentication within a given time window.\nDefault Failure count is 10 and 1 successful login with default Time Window is 5 minutes.'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "MFASpammingfollowedbySuccessfullogin.yaml",
      "queryFrequency": "PT1D",
      "query": "// Filter for sign-in logs ingested within the last day\nSigninLogs\n| where ingestion_time() > ago(1d)\n// Filter for records with AuthenticationRequirement set to multiFactorAuthentication\n| where AuthenticationRequirement == \"multiFactorAuthentication\"\n// Extract information from dynamic columns DeviceDetail and LocationDetails\n| extend DeviceDetail = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n// Extract specific attributes from DeviceDetail and LocationDetails\n| extend\n      OS = tostring(DeviceDetail.operatingSystem),\n      Browser = tostring(DeviceDetail.browser),\n      State = tostring(LocationDetails.state),\n      City = tostring(LocationDetails.city),\n      Region = tostring(LocationDetails.countryOrRegion)\n// Expand multi-value property AuthenticationDetails into separate records\n| mv-expand todynamic(AuthenticationDetails)\n// Parse AuthResult from JSON in AuthenticationDetails and convert to string\n| extend AuthResult = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)\n// Summarize data by aggregating statistics for each user, IP, and AuthResult\n| summarize FailedAttempts = countif(AuthResult == \"MFA denied; user declined the authentication\" or AuthResult == \"MFA denied; user did not respond to mobile app notification\"), SuccessfulAttempts = countif(AuthResult == \"MFA successfully completed\"), InvolvedOS = make_set(OS, 5), InvolvedBrowser = make_set(Browser), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, IPAddress, State, City, Region\n// Calculate AuthenticationWindow by finding time difference between start and end times\n| extend AuthenticationWindow = (EndTime - StartTime)\n// Filter for records with more than 10 failed attempts in 5-minute window and at least 1 successful attempt\n| where FailedAttempts > 10 and AuthenticationWindow <= 5m and SuccessfulAttempts >= 1\n// Extract user's name and UPN suffix using split function\n| extend Name = tostring(split(UserPrincipalName, '@', 0)[0]), UPNSuffix = tostring(split(UserPrincipalName, '@', 1)[0])",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Target"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT7D",
      "name": "Multiple admin membership removals from newly created admin.",
      "id": "cda5928c-2c1e-4575-9dfa-07568bc27a4f",
      "tactics": "Impact",
      "kind": "Scheduled",
      "description": "'This query detects when newly created Global admin removes multiple existing global admins which can be an attempt by adversaries to lock down organization and retain sole access. \n Investigate reasoning and intention of multiple membership removal by new Global admins and take necessary actions accordingly.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "MultipleAdmin_membership_removals_from_NewAdmin.yaml",
      "queryFrequency": "PT1H",
      "query": "let lookback = 7d; \nlet timeframe = 1h; \nlet GlobalAdminsRemoved = AuditLogs \n| where TimeGenerated > ago(timeframe) \n| where Category =~ \"RoleManagement\" \n| where AADOperationType in (\"Unassign\", \"RemoveEligibleRole\") \n| where ActivityDisplayName has_any (\"Remove member from role\", \"Remove eligible member from role\") \n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend Target = tostring(TargetResource.userPrincipalName),\n               props = TargetResource.modifiedProperties\n  )\n| mv-apply Property = props on \n      (\n          where Property.displayName =~ \"Role.DisplayName\"\n          | extend RoleName = trim('\"',tostring(Property.oldValue))\n      )\n| where RoleName =~ \"Global Administrator\" // Add other Privileged role if applicable\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend Initiator = iif(isnotempty(InitiatingAppName), InitiatingAppName, InitiatingUserPrincipalName) \n| where Initiator != \"MS-PIM\" and Initiator != \"MS-PIM-Fairfax\"  // Filtering PIM events  \n| summarize RemovedGlobalAdminTime = max(TimeGenerated), TargetAdmins = make_set(Target,100) by OperationName, RoleName, Initiator, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingIpAddress, Result; \nlet GlobalAdminsAdded = AuditLogs \n| where TimeGenerated > ago(lookback) \n| where Category =~ \"RoleManagement\" \n| where AADOperationType in (\"Assign\", \"AssignEligibleRole\") \n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\") and Result == \"success\" \n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend Target = tostring(TargetResource.userPrincipalName),\n               props = TargetResource.modifiedProperties\n  )\n| mv-apply Property = props on \n      (\n          where Property.displayName =~ \"Role.DisplayName\"\n          | extend RoleName = trim('\"',tostring(Property.newValue))\n      )\n| where RoleName =~ \"Global Administrator\" // Add other Privileged role if applicable\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend Initiator = iif(isnotempty(InitiatingAppName), InitiatingAppName, tostring(InitiatedBy.user.userPrincipalName)) \n| where Initiator != \"MS-PIM\" and Initiator != \"MS-PIM-Fairfax\"  // Filtering PIM events \n| summarize AddedGlobalAdminTime = max(TimeGenerated) by OperationName, RoleName, Target, Initiator, Result;\nGlobalAdminsAdded \n| join kind= inner GlobalAdminsRemoved on $left.Target == $right.Initiator \n| where AddedGlobalAdminTime < RemovedGlobalAdminTime \n| extend NoofAdminsRemoved = array_length(TargetAdmins) \n| where NoofAdminsRemoved > 1\n| project AddedGlobalAdminTime, Initiator, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingIpAddress, Target, RemovedGlobalAdminTime, TargetAdmins, NoofAdminsRemoved\n| extend TargetName = tostring(split(Target,'@',0)[0]), TargetUPNSuffix = tostring(split(Target,'@',1)[0])\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1531",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "UserIP"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "New CloudShell User",
      "id": "6d7214d9-4a28-44df-aafb-0910b9e6ae3e",
      "tactics": "Execution",
      "kind": "Scheduled",
      "description": "'Identifies when a user creates an Azure CloudShell for the first time.\nMonitor this activity to ensure only the expected users are using CloudShell.'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "New-CloudShell-User.yaml",
      "queryFrequency": "PT1D",
      "query": "let match_window = 3m;\nAzureActivity\n| where ResourceGroup has \"cloud-shell\"\n| where (OperationNameValue =~ \"Microsoft.Storage/storageAccounts/listKeys/action\")\n| where ActivityStatusValue =~ \"Success\"\n| extend TimeKey = bin(TimeGenerated, match_window), AzureIP = CallerIpAddress\n| join kind = inner\n(AzureActivity\n| where ResourceGroup has \"cloud-shell\"\n| where (OperationNameValue =~ \"Microsoft.Storage/storageAccounts/write\")\n| extend TimeKey = bin(TimeGenerated, match_window), UserIP = CallerIpAddress\n) on Caller, TimeKey\n| summarize count() by TimeKey, Caller, ResourceGroup, SubscriptionId, TenantId, AzureIP, UserIP, HTTPRequest, Type, Properties, CategoryValue, OperationList = strcat(OperationNameValue, ' , ', OperationNameValue1)\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])",
      "techniques": "T1059",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "New access credential added to Application or Service Principal",
      "id": "79566f41-df67-4e10-a703-c38a6213afd8",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "'This will alert when an admin or app owner account adds a new credential to an Application or Service Principal where a verify KeyCredential was already present for the app.\nIf a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "NewAppOrServicePrincipalCredential.yaml",
      "queryFrequency": "PT1H",
      "query": "AuditLogs\n| where OperationName has_any (\"Add service principal\", \"Certificates and secrets management\") // captures \"Add service principal\", \"Add service principal credentials\", and \"Update application - Certificates and secrets management\" events\n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"Application\"\n      | extend targetDisplayName = tostring(TargetResource.displayName),\n               targetId = tostring(TargetResource.id),\n               targetType = tostring(TargetResource.type),\n               keyEvents = TargetResource.modifiedProperties\n  )\n| mv-apply Property = keyEvents on \n  (\n      where Property.displayName =~ \"KeyDescription\"\n      | extend new_value_set = parse_json(tostring(Property.newValue)),\n               old_value_set = parse_json(tostring(Property.oldValue))\n  )\n| where old_value_set != \"[]\"\n| extend diff = set_difference(new_value_set, old_value_set)\n| where isnotempty(diff)\n| parse diff with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| where keyUsage =~ \"Verify\"\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n// The below line is currently commented out but Microsoft Sentinel users can modify this query to show only Application or only Service Principal events in their environment\n//| where targetType =~ \"Application\" // or targetType =~ \"ServicePrincipal\"\n| project-away diff, new_value_set, old_value_set\n| project-reorder TimeGenerated, OperationName, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId\n| extend Name = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1550.001",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUser"
            },
            {
              "identifier": "Name",
              "columnName": "UserName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingSPID"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIp"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "DomainName",
              "columnName": "DomainAdded"
            }
          ],
          "entityType": "DNS"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "New onmicrosoft domain added to tenant",
      "id": "4f42b94f-b210-42d1-a023-7fa1c51d969f",
      "tactics": "ResourceDevelopment",
      "kind": "Scheduled",
      "description": "'This detection looks for new onmicrosoft domains being added to a tenant. \nAn attacker who compromises a tenant may register a new onmicrosoft domain in order to masquerade as a service provider for launching phishing campaigns.\nDomain additions are not a common occurrence and users should validate that the domain was added by a legitimate user, with a legitimate purpose.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "NewOnmicrosoftDomainAdded.yaml",
      "queryFrequency": "PT1H",
      "query": "AuditLogs\n| where AADOperationType == \"Add\"\n| where Result == \"success\"\n| where OperationName in (\"Add verified domain\", \"Add unverified domain\")\n| extend InitiatedBy = parse_json(InitiatedBy)\n| extend InitiatingUser = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIp = tostring(InitiatedBy.user.ipAddress)\n| extend InitiatingApp = tostring(InitiatedBy.app.displayName)\n| extend InitiatingSPID = tostring(InitiatedBy.app.servicePrincipalId)\n| extend DomainAdded = tostring(TargetResources[0].displayName)\n| where DomainAdded has \"onmicrosoft\"\n| extend ActionInitiatedBy = case(isnotempty(InitiatingUser), InitiatingUser, strcat(InitiatingApp, \" - \", InitiatingSPID))\n| extend UserName = split(InitiatingUser, \"@\")[0]\n| extend UPNSuffix = split(InitiatingUser, \"@\")[1]\n| project-reorder TimeGenerated, OperationName, DomainAdded, ActionInitiatedBy, InitiatingIp",
      "techniques": "T1585.003",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "AadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "Suspicious Resource deployment",
      "id": "9fb57e58-3ed8-4b89-afcf-c8e786508b1c",
      "tactics": "Impact",
      "kind": "Scheduled",
      "description": "'Identifies when a rare Resource and ResourceGroup deployment occurs by a previously unseen caller.'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "NewResourceGroupsDeployedTo.yaml",
      "queryFrequency": "PT1D",
      "query": "// Add or remove operation names below as per your requirements. For operations lists, please refer to https://learn.microsoft.com/en-us/Azure/role-based-access-control/resource-provider-operations#all\nlet szOperationNames = dynamic([\"Microsoft.Compute/virtualMachines/write\", \"Microsoft.Resources/deployments/write\", \"Microsoft.Resources/subscriptions/resourceGroups/write\"]);\nlet starttime = 14d;\nlet endtime = 1d;\nlet RareCaller = AzureActivity\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where OperationNameValue in~ (szOperationNames)\n| summarize count() by CallerIpAddress, Caller, OperationNameValue, bin(TimeGenerated,1d)\n// Returns all the records from the right side that don't have matches from the left.\n| join kind=rightantisemi (\nAzureActivity\n| where TimeGenerated > ago(endtime)\n| where OperationNameValue in~ (szOperationNames)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = make_set(TimeGenerated,100), ActivityStatusValue = make_set(ActivityStatusValue,100), CorrelationIds = make_set(CorrelationId,100), ResourceGroups = make_set(ResourceGroup,100), ResourceIds = make_set(_ResourceId,100), ActivityCountByCallerIPAddress = count()\nby CallerIpAddress, Caller, OperationNameValue) on CallerIpAddress, Caller, OperationNameValue;\nRareCaller\n| extend Name = iif(Caller has '@',tostring(split(Caller,'@',0)[0]),\"\")\n| extend UPNSuffix = iif(Caller has '@',tostring(split(Caller,'@',1)[0]),\"\")\n| extend AadUserId = iif(Caller !has '@',Caller,\"\")",
      "techniques": "T1496",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT5H",
      "name": "NRT Modified domain federation trust settings",
      "id": "8540c842-5bbc-4a24-9fb2-a836c0e55a51",
      "tactics": [
        "CredentialAccess",
        "Persistence",
        "PrivilegeEscalation"
      ],
      "kind": "NRT",
      "description": "'This will alert when a user or application modifies the federation settings on the domain or Update domain authentication from Managed to Federated.\nFor example, this alert will trigger when a new Active Directory Federated Service (ADFS) TrustedRealm object, such as a signing certificate, is added to the domain.\nModification to domain federation settings should be rare. Confirm the added or modified target domain/URL is legitimate administrator behavior.\nTo understand why an authorized user may update settings for a federated domain in Office 365, Azure, or Intune, see: https://docs.microsoft.com/office365/troubleshoot/active-directory/update-federated-domain-office-365.\nFor details on security realms that accept security tokens, see the ADFS Proxy Protocol (MS-ADFSPP) specification: https://docs.microsoft.com/openspecs/windows_protocols/ms-adfspp/e7b9ea73-1980-4318-96a6-da559486664b.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "High",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "NRT_ADFSDomainTrustMods.yaml",
      "queryFrequency": "PT5H",
      "query": "AuditLogs\n| where OperationName =~ \"Set federation settings on domain\" or OperationName =~ \"Set domain authentication\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-apply Property = modifiedProperties on \n  (\n      where Property.displayName =~ \"LiveType\"\n      | extend targetDisplayName = tostring(Property.displayName),\n               NewDomainValue = tostring(Property.newValue)\n  )\n| extend Federated = iif(OperationName =~ \"Set domain authentication\", iif(NewDomainValue has \"Federated\", True, False), True)\n| where Federated == True\n| mv-expand AdditionalDetails\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| project-reorder TimeGenerated, OperationName, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, AADOperationType, targetDisplayName, Result, UserAgent, CorrelationId, TenantId, AADTenantId\n| extend Name = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": [
        "T1555",
        "T1098"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Target"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT5H",
      "name": "NRT Authentication Methods Changed for VIP Users",
      "id": "29e99017-e28d-47be-8b9a-c8c711f8a903",
      "tactics": "Persistence",
      "kind": "NRT",
      "description": "'Identifies authentication methods being changed for a list of VIP users watchlist. This could be an indication of an attacker adding an auth method to the account so they can have continued access.'",
      "severity": "Medium",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "NRT_AuthenticationMethodsChangedforVIPUsers.yaml",
      "queryFrequency": "PT5H",
      "query": "let security_info_actions = dynamic([\"User registered security info\", \"User changed default security info\", \"User deleted security info\", \"Admin updated security info\", \"User reviewed security info\", \"Admin deleted security info\", \"Admin registered security info\"]);\nlet VIPUsers = (_GetWatchlist('VIPUsers') | distinct \"User Principal Name\");\nAuditLogs\n| where Category =~ \"UserManagement\"\n| where ActivityDisplayName in (security_info_actions)\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend Target = trim(@'\"',tolower(tostring(TargetResource.userPrincipalName)))\n  )\n| where Target in~ (VIPUsers)\n| summarize Start=min(TimeGenerated), End=max(TimeGenerated), Actions = make_set(ResultReason) by InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, Result, Target\n| extend TargetName = tostring(split(Target,'@',0)[0]), TargetUPNSuffix = tostring(split(Target,'@',1)[0])\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1098",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "HostName",
              "columnName": "ComputerName"
            }
          ],
          "entityType": "Host"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT5H",
      "name": "NRT Creation of expensive computes in Azure",
      "id": "56fe0db0-6779-46fa-b3c5-006082a53064",
      "tactics": "DefenseEvasion",
      "kind": "NRT",
      "description": "'Identifies the creation of large size or expensive VMs (with GPUs or with a large number of virtual CPUs) in Azure.\nAn adversary may create new or update existing virtual machines to evade defenses or use them for cryptomining purposes.\nFor Windows/Linux Vm Sizes, see https://docs.microsoft.com/azure/virtual-machines/windows/sizes \nAzure VM Naming Conventions, see https://docs.microsoft.com/azure/virtual-machines/vm-naming-conventions'",
      "severity": "Medium",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "NRT_Creation_of_Expensive_Computes_in_Azure.yaml",
      "queryFrequency": "PT5H",
      "query": "let tokens = dynamic([\"416\",\"208\",\"192\",\"128\",\"120\",\"96\",\"80\",\"72\",\"64\",\"48\",\"44\",\"40\",\"nc12\",\"nc24\",\"nv24\"]);\nlet operationList = dynamic([\"microsoft.compute/virtualmachines/write\", \"microsoft.resources/deployments/write\"]);\nAzureActivity\n| where OperationNameValue in~ (operationList)\n| where ActivityStatusValue startswith \"Accept\"\n| where Properties has 'vmSize'\n| extend parsed_property= parse_json(tostring((parse_json(Properties).responseBody))).properties\n| extend vmSize = tostring((parsed_property.hardwareProfile).vmSize)\n| mv-apply token=tokens to typeof(string) on (where vmSize contains token)\n| extend ComputerName = tostring((parsed_property.osProfile).computerName)\n| project TimeGenerated, OperationNameValue, ActivityStatusValue, Caller, CallerIpAddress, ComputerName, vmSize\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])",
      "techniques": "T1578",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT5H",
      "name": "NRT First access credential added to Application or Service Principal where no credential was present",
      "id": "b6988c32-4f3b-4a45-8313-b46b33061a74",
      "tactics": "DefenseEvasion",
      "kind": "NRT",
      "description": "'This will alert when an admin or app owner account adds a new credential to an Application or Service Principal where there was no previous verify KeyCredential associated.\nIf a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "Medium",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "nrt_FirstAppOrServicePrincipalCredential.yaml",
      "queryFrequency": "PT5H",
      "query": "AuditLogs\n| where OperationName has_any (\"Add service principal\", \"Certificates and secrets management\")\n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| mv-apply TargetResource = TargetResources on \n  (\n    where TargetResource.type =~ \"Application\"\n    | extend targetDisplayName = tostring(TargetResource.displayName),\n             targetId = tostring(TargetResource.id),\n             targetType = tostring(TargetResource.type),\n             keyEvents = TargetResource.modifiedProperties\n  )\n|  mv-apply Property = keyEvents on \n (\n  where Property.displayName =~ \"KeyDescription\"\n  | extend new_value_set = parse_json(tostring(Property.newValue)),\n           old_value_set = parse_json(tostring(Property.oldValue))\n )\n| where old_value_set == \"[]\"\n| mv-expand new_value_set\n| parse new_value_set with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| where keyUsage == \"Verify\"\n | mv-apply AdditionalDetail = AdditionalDetails on \n  (\n    where AdditionalDetail.key =~ \"User-Agent\"\n    | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n//| where targetType =~ \"Application\" // or targetType =~ \"ServicePrincipal\"\n| project-away new_value_set, old_value_set\n| project-reorder TimeGenerated, OperationName, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1550.001",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "InitiatingAppName"
            },
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT5H",
      "name": "NRT New access credential added to Application or Service Principal",
      "id": "e42e889a-caaf-4dbb-aec6-371b37d64298",
      "tactics": "DefenseEvasion",
      "kind": "NRT",
      "description": "'This will alert when an admin or app owner account adds a new credential to an Application or Service Principal where a verify KeyCredential was already present for the app.\nIf a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "Medium",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "NRT_NewAppOrServicePrincipalCredential.yaml",
      "queryFrequency": "PT5H",
      "query": "AuditLogs\n| where OperationName has_any (\"Add service principal\", \"Certificates and secrets management\") // captures \"Add service principal\", \"Add service principal credentials\", and \"Update application - Certificates and secrets management\" events\n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"Application\"\n      | extend targetDisplayName = tostring(TargetResource.displayName),\n               targetId = tostring(TargetResource.id),\n               targetType = tostring(TargetResource.type),\n               keyEvents = TargetResource.modifiedProperties\n  )\n| mv-apply Property = keyEvents on \n  (\n      where Property.displayName =~ \"KeyDescription\"\n      | extend new_value_set = parse_json(tostring(Property.newValue)),\n               old_value_set = parse_json(tostring(Property.oldValue))\n  )\n| where old_value_set != \"[]\"\n| extend diff = set_difference(new_value_set, old_value_set)\n| where diff != \"[]\"\n| parse diff with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| where keyUsage =~ \"Verify\"\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n// The below line is currently commented out but Microsoft Sentinel users can modify this query to show only Application or only Service Principal events in their environment\n//| where targetType =~ \"Application\" // or targetType =~ \"ServicePrincipal\"\n| project-away diff, new_value_set, old_value_set\n| project-reorder TimeGenerated, OperationName, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1550",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "TargetUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT5H",
      "name": "NRT PIM Elevation Request Rejected",
      "id": "5db427b2-f406-4274-b413-e9fcb29412f8",
      "tactics": "Persistence",
      "kind": "NRT",
      "description": "'Identifies when a user is rejected for a privileged role elevation via PIM. Monitor rejections for indicators of attacker compromise of the requesting account.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-identity-management'",
      "severity": "High",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "NRT_PIMElevationRequestRejected.yaml",
      "queryFrequency": "PT5H",
      "query": "AuditLogs\n| where ActivityDisplayName =~ 'Add member to role request denied (PIM activation)'\n| mv-apply ResourceItem = TargetResources on \n  (\n      where ResourceItem.type =~ \"Role\"\n      | extend Role = trim(@'\"',tostring(ResourceItem.displayName))\n  )\n| mv-apply ResourceItem = TargetResources on \n  (\n      where ResourceItem.type =~ \"User\"\n      | extend TargetUserPrincipalName = trim(@'\"',tostring(ResourceItem.userPrincipalName))\n  )\n| where ResultReason != \"RoleAssignmentExists\"\n| where isnotempty(InitiatedBy.user)\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend TargetName = tostring(split(TargetUserPrincipalName,'@',0)[0]), TargetUPNSuffix = tostring(split(TargetUserPrincipalName,'@',1)[0])\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])\n| project-reorder TimeGenerated, TargetUserPrincipalName, Role, OperationName, Result, ResultDescription",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "TargetUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT5H",
      "name": "NRT Privileged Role Assigned Outside PIM",
      "id": "14f6da04-2f96-44ee-9210-9ccc1be6401e",
      "tactics": "PrivilegeEscalation",
      "kind": "NRT",
      "description": "'Identifies a privileged role being assigned to a user outside of PIM\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'",
      "severity": "Low",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "NRT_PrivlegedRoleAssignedOutsidePIM.yaml",
      "queryFrequency": "PT5H",
      "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where OperationName has \"Add member to role outside of PIM\"\n        or (LoggedByService =~ \"Core Directory\" and OperationName =~ \"Add member to role\" and Identity != \"MS-PIM\" and Identity != \"MS-PIM-Fairfax\")\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend TargetUserPrincipalName = tostring(TargetResource.userPrincipalName)\n  )\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend TargetName = tostring(split(TargetUserPrincipalName,'@',0)[0]), TargetUPNSuffix = tostring(split(TargetUserPrincipalName,'@',1)[0])\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "TargetUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT5H",
      "name": "NRT User added to Microsoft Entra ID Privileged Groups",
      "id": "70fc7201-f28e-4ba7-b9ea-c04b96701f13",
      "tactics": [
        "Persistence",
        "PrivilegeEscalation"
      ],
      "kind": "NRT",
      "description": "'This will alert when a user is added to any of the Privileged Groups.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\nFor Administrator role permissions in Microsoft Entra ID please see https://docs.microsoft.com/azure/active-directory/users-groups-roles/directory-assign-admin-roles'",
      "severity": "Medium",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "NRT_UseraddedtoPrivilgedGroups.yaml",
      "queryFrequency": "PT5H",
      "query": "let OperationList = dynamic([\"Add member to role\",\"Add eligible member to role\"]);\nlet PrivilegedGroups = dynamic([\"UserAccountAdmins\",\"PrivilegedRoleAdmins\",\"TenantAdmins\",\"PrivilegedAuthenticationAdmins\"]);\nAuditLogs\n| where Category =~ \"RoleManagement\"\n| where OperationName in~ (OperationList)\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend TargetUserPrincipalName = tostring(TargetResource.userPrincipalName),\n               modProps = TargetResource.modifiedProperties\n  )\n| mv-apply Property = modProps on \n  (\n      where Property.displayName =~ \"Role.WellKnownObjectName\"\n      | extend DisplayName = trim('\"',tostring(Property.displayName)),\n               GroupName = trim('\"',tostring(Property.newValue))\n  )\n| extend InitiatingAppId = tostring(InitiatedBy.app.appId)\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingAppServicePrincipalName = tostring(InitiatedBy.app.servicePrincipalName)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))        \n| extend InitiatingUserRoles = InitiatedBy.user.roles\n| where GroupName in~ (PrivilegedGroups)\n// If you don't want to alert for operations from PIM, remove below filtering for MS-PIM.\n//| where InitiatingAppName != \"MS-PIM\" and InitiatingAppName != \"MS-PIM-Fairfax\"\n| project TimeGenerated, AADOperationType, Category, OperationName, AADTenantId, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppId, InitiatingAppServicePrincipalId, InitiatingIpAddress, InitiatingUserRoles, DisplayName, GroupName, TargetUserPrincipalName\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])\n| extend TargetName = tostring(split(TargetUserPrincipalName,'@',0)[0]), TargetUPNSuffix = tostring(split(TargetUserPrincipalName,'@',1)[0])",
      "techniques": [
        "T1098",
        "T1078"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT5H",
      "name": "NRT Microsoft Entra ID Hybrid Health AD FS New Server",
      "id": "ec491363-5fe7-4eff-b68e-f42dcb76fcf6",
      "tactics": "DefenseEvasion",
      "kind": "NRT",
      "description": "'This detection uses AzureActivity logs (Administrative category) to identify the creation or update of a server instance in an Microsoft Entra ID Hybrid Health AD FS service.\nA threat actor can create a new AD Health ADFS service and create a fake server instance to spoof AD FS signing logs. There is no need to compromise an on-premises AD FS server.\nThis can be done programmatically via HTTP requests to Azure. More information in this blog: https://o365blog.com/post/hybridhealthagent/'",
      "severity": "Medium",
      "triggerOperator": "GreaterThan",
      "triggerThreshold": 0,
      "sourceFile": "NRT-AADHybridHealthADFSNewServer.yaml",
      "queryFrequency": "PT5H",
      "query": "AzureActivity\n| where CategoryValue =~ 'Administrative'\n| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'\n| where _ResourceId has 'AdFederationService'\n| where OperationNameValue =~ 'Microsoft.ADHybridHealthService/services/servicemembers/action'\n| extend claimsJson = parse_json(Claims)\n| extend AppId = tostring(claimsJson.appid), AccountName = tostring(claimsJson.name), Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])\n| project-away claimsJson",
      "techniques": "T1578",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "ResourceId",
              "columnName": "_ResourceId"
            }
          ],
          "entityType": "AzureResource"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT15M",
      "name": "NSG flow logs disabled or deleted",
      "id": "8a1d8c12-8d0c-4e44-97d1-7b1320870d8d",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "'Detects when NSG flow logs are disabled or deleted. Disabling flow logs reduces network visibility and can be used to evade detection of suspicious outbound traffic and lateral movement.'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "NSGFlowLogsDisabledOrDeleted.yaml",
      "queryFrequency": "PT15M",
      "query": "let queryFrequency = 15m;\nlet FlowLogsChanges = AzureActivity\n| where ingestion_time() > ago(queryFrequency)\n| where ActivityStatusValue =~ \"Success\"\n| where tolower(OperationNameValue) has \"microsoft.network/networkwatchers\" and (tolower(OperationNameValue) endswith \"/flowlogs/write\" or tolower(OperationNameValue) endswith \"/flowlogs/delete\")\n| extend requestBody = tostring(parse_json(Properties).requestbody)\n| extend request = parse_json(requestBody)\n| extend props = coalesce(request.properties, request.Properties)\n| extend Enabled = tobool(props.enabled)\n| extend IsDelete = tolower(OperationNameValue) endswith \"/flowlogs/delete\"\n| extend IsDisabled = (tolower(OperationNameValue) endswith \"/flowlogs/write\") and (Enabled == false)\n| where IsDelete or IsDisabled\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0]);\nFlowLogsChanges\n| project\n    TimeGenerated,\n    Caller,\n    Name,\n    UPNSuffix,\n    CallerIpAddress,\n    OperationNameValue,\n    ResourceGroup,\n    _ResourceId,\n    Resource,\n    CorrelationId,\n    IsDelete,\n    IsDisabled,\n    Enabled",
      "techniques": "T1562",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "ResourceId",
              "columnName": "_ResourceId"
            }
          ],
          "entityType": "AzureResource"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT15M",
      "name": "NSG inbound allow from Internet to management ports",
      "id": "6b6e8b03-33c3-4c2a-b3a9-6f8e8b5c7c61",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "'Detects creation or update of a Network Security Group (NSG) security rule that allows inbound access from the Internet (or any source) to common management ports. This is frequently a misconfiguration that enables initial access via exposed services.'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "NSGInboundInternetToManagementPorts.yaml",
      "queryFrequency": "PT15M",
      "query": "let queryFrequency = 15m;\nlet mgmtPorts = dynamic([\"22\",\"3389\",\"5985\",\"5986\",\"1433\",\"3306\",\"5432\"]);\nAzureActivity\n| where ingestion_time() > ago(queryFrequency)\n| where ActivityStatusValue =~ \"Success\"\n| where tolower(OperationNameValue) has \"microsoft.network/networksecuritygroups\" and tolower(OperationNameValue) endswith \"/securityrules/write\"\n| extend requestBody = tostring(parse_json(Properties).requestbody)\n| extend request = parse_json(requestBody)\n| extend ruleProps = coalesce(request.properties, request.Properties)\n| extend Access = tostring(ruleProps.access), Direction = tostring(ruleProps.direction), Protocol = tostring(ruleProps.protocol)\n| extend SourcePrefix = tostring(ruleProps.sourceAddressPrefix), SourcePrefixes = tostring(ruleProps.sourceAddressPrefixes)\n| extend DestinationPrefix = tostring(ruleProps.destinationAddressPrefix), DestinationPrefixes = tostring(ruleProps.destinationAddressPrefixes)\n| extend DestinationPort = tostring(ruleProps.destinationPortRange), DestinationPorts = tostring(ruleProps.destinationPortRanges)\n| extend DestPortsCombined = iff(isnotempty(DestinationPorts), DestinationPorts, DestinationPort)\n| extend SrcAny = (SourcePrefix in~ (\"*\", \"Internet\", \"0.0.0.0/0\", \"::/0\"))\n    or (SourcePrefixes has \"0.0.0.0/0\") or (SourcePrefixes has \"\\\"Internet\\\"\") or (SourcePrefixes has \"*\")\n| extend IsWidePort = DestPortsCombined == \"*\" or DestPortsCombined has \"1-65535\" or DestPortsCombined has \"0-65535\"\n| extend IsMgmtPort = DestPortsCombined has_any (mgmtPorts)\n| where Direction =~ \"Inbound\" and Access =~ \"Allow\" and SrcAny and (IsWidePort or IsMgmtPort)\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])\n| project\n    TimeGenerated,\n    Caller,\n    Name,\n    UPNSuffix,\n    CallerIpAddress,\n    OperationNameValue,\n    ResourceGroup,\n    _ResourceId,\n    Resource,\n    CorrelationId,\n    Access,\n    Direction,\n    Protocol,\n    SourcePrefix,\n    DestinationPrefix,\n    DestPortsCombined",
      "techniques": "T1133",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "ResourceId",
              "columnName": "_ResourceId"
            }
          ],
          "entityType": "AzureResource"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT15M",
      "name": "NSG outbound allow to Internet (risky egress)",
      "id": "3f3a2c47-1d4f-4b0a-8f43-7d9d5a3d2d71",
      "tactics": [
        "CommandAndControl",
        "Exfiltration"
      ],
      "kind": "Scheduled",
      "description": "'Detects creation or update of a Network Security Group (NSG) security rule that allows broad outbound (egress) access to the Internet. Open egress can enable command-and-control and data exfiltration, and is often inconsistent with least-privilege network segmentation.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "NSGOutboundAllowToInternet.yaml",
      "queryFrequency": "PT15M",
      "query": "let queryFrequency = 15m;\nlet riskyEgressPorts = dynamic([\"21\",\"22\",\"23\",\"25\",\"53\",\"80\",\"443\",\"445\",\"3389\",\"4444\",\"8080\",\"8443\"]);\nAzureActivity\n| where ingestion_time() > ago(queryFrequency)\n| where ActivityStatusValue =~ \"Success\"\n| where tolower(OperationNameValue) has \"microsoft.network/networksecuritygroups\" and tolower(OperationNameValue) endswith \"/securityrules/write\"\n| extend requestBody = tostring(parse_json(Properties).requestbody)\n| extend request = parse_json(requestBody)\n| extend ruleProps = coalesce(request.properties, request.Properties)\n| extend Access = tostring(ruleProps.access), Direction = tostring(ruleProps.direction), Protocol = tostring(ruleProps.protocol)\n| extend DestinationPrefix = tostring(ruleProps.destinationAddressPrefix), DestinationPrefixes = tostring(ruleProps.destinationAddressPrefixes)\n| extend DestinationPort = tostring(ruleProps.destinationPortRange), DestinationPorts = tostring(ruleProps.destinationPortRanges)\n| extend DestPortsCombined = iff(isnotempty(DestinationPorts), DestinationPorts, DestinationPort)\n| extend DestAny = (DestinationPrefix in~ (\"*\", \"Internet\", \"0.0.0.0/0\", \"::/0\"))\n    or (DestinationPrefixes has \"0.0.0.0/0\") or (DestinationPrefixes has \"\\\"Internet\\\"\") or (DestinationPrefixes has \"*\")\n| extend IsWidePort = DestPortsCombined == \"*\" or DestPortsCombined has \"1-65535\" or DestPortsCombined has \"0-65535\"\n| extend IsRiskyPort = DestPortsCombined has_any (riskyEgressPorts)\n| where Direction =~ \"Outbound\" and Access =~ \"Allow\" and DestAny and (IsWidePort or IsRiskyPort)\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])\n| project\n    TimeGenerated,\n    Caller,\n    Name,\n    UPNSuffix,\n    CallerIpAddress,\n    OperationNameValue,\n    ResourceGroup,\n    _ResourceId,\n    Resource,\n    CorrelationId,\n    Access,\n    Direction,\n    Protocol,\n    DestinationPrefix,\n    DestPortsCombined",
      "techniques": [
        "T1071",
        "T1041"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "TargetUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2H",
      "name": "PIM Elevation Request Rejected",
      "id": "7d7e20f8-3384-4b71-811c-f5e950e8306c",
      "tactics": "Persistence",
      "kind": "Scheduled",
      "description": "'Identifies when a user is rejected for a privileged role elevation via PIM. Monitor rejections for indicators of attacker compromise of the requesting account.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-identity-management'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "PIMElevationRequestRejected.yaml",
      "queryFrequency": "PT2H",
      "query": "AuditLogs\n| where ActivityDisplayName =~'Add member to role request denied (PIM activation)'\n| mv-apply ResourceItem = TargetResources on \n  (\n      where ResourceItem.type =~ \"Role\"\n      | extend Role = trim(@'\"',tostring(ResourceItem.displayName))\n  )\n| mv-apply ResourceItem = TargetResources on \n  (\n      where ResourceItem.type =~ \"User\"\n      | extend TargetUserPrincipalName = trim(@'\"',tostring(ResourceItem.userPrincipalName))\n  )\n| where isnotempty(InitiatedBy.user)\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend TargetName = tostring(split(TargetUserPrincipalName,'@',0)[0]), TargetUPNSuffix = tostring(split(TargetUserPrincipalName,'@',1)[0])\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])\n| project-reorder TimeGenerated, TargetUserPrincipalName, Role, OperationName, Result, ResultDescription",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "NTDomain",
              "columnName": "UserDomain"
            },
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "Possible SignIn from Azure Backdoor",
      "id": "fa00014c-c5f4-4715-8f5b-ba567e19e41e",
      "tactics": "Persistence",
      "kind": "Scheduled",
      "description": "'Identifies when a user adds an unverified domain as an authentication method, followed by a sign-in from a user the newly added domain. Threat actors may add custom domains to create a backdoor to your tenant. It's important to monitor whenever custom domains are added to the tenant.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "PossibleSignInfromAzureBackdoor.yaml",
      "queryFrequency": "PT1H",
      "query": "// Microsoft Entra ID  Backdoors: Identity Federation\n//Ref: https://www.inversecos.com/2021/11/how-to-detect-azure-active-directory.html\nAuditLogs\n| where OperationName == \"Add unverified domain\"\n| where Result == \"success\"\n| extend InitiatedBy = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend DomainName = tostring(TargetResources[0].displayName)\n| summarize DomainAddedTime = min(TimeGenerated), ModifiedProperties = make_set(parse_json(TargetResources[0].modifiedProperties),1048576) by InitiatedBy, DomainName\n| join kind=inner (\nSigninLogs\n| where ResultType == \"0\"\n| extend UserDomain = tostring(parse_json(split(UserPrincipalName,\"@\",1)[0]))\n| summarize SignInTime = min(TimeGenerated)  by UserPrincipalName, IPAddress, tostring(LocationDetails),AppDisplayName,ResourceDisplayName,UserDomain\n) on $left.DomainName == $right.UserDomain\n// Getting UserName and Domain\n| extend Name = split(UserPrincipalName,\"@\",0), Domain = split(UserPrincipalName,\"@\",1)\n| mv-expand Name,Domain",
      "techniques": "T1098",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "Privileged Accounts - Sign in Failure Spikes",
      "id": "34c5aff9-a8c2-4601-9654-c7e46342d03b",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "' Identifies spike in failed sign-ins from Privileged accounts. Privileged accounts list can be based on IdentityInfo UEBA table.\nSpike is determined based on Time series anomaly which will look at historical baseline values.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "PrivilegedAccountsSigninFailureSpikes.yaml",
      "queryFrequency": "PT1D",
      "query": "let starttime = 14d;\nlet timeframe = 1d;\nlet scorethreshold = 3;\nlet baselinethreshold = 5;\nlet aadFunc = (tableName:string){\n    IdentityInfo\n    | where TimeGenerated > ago(starttime)\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\n    | mv-expand AssignedRoles\n    | where AssignedRoles contains 'Admin' or GroupMembership has \"Admin\"\n    | summarize Roles = make_list(AssignedRoles) by AccountUPN = tolower(AccountUPN)\n    | join kind=inner (\n        table(tableName)\n        | where TimeGenerated between (startofday(ago(starttime))..startofday(now()))\n        | where ResultType != 0\n        | extend UserPrincipalName = tolower(UserPrincipalName)\n    ) on $left.AccountUPN == $right.UserPrincipalName\n    | extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, Roles = tostring(Roles)\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nlet allSignins = union isfuzzy=true aadSignin, aadNonInt;\nlet TimeSeriesAlerts = \n    allSignins\n    | make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step 1h by UserPrincipalName, Roles\n    | extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')\n    | mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n    // Filtering low count events per baselinethreshold\n    | where anomalies > 0 and baseline > baselinethreshold\n    | extend AnomalyHour = TimeGenerated\n    | project UserPrincipalName, Roles, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;\n// Filter the alerts for specified timeframe\nTimeSeriesAlerts\n| where TimeGenerated > startofday(ago(timeframe))\n| join kind=inner ( \n    allSignins\n    | where TimeGenerated > startofday(ago(timeframe))\n    // create a new column and round to hour\n    | extend DateHour = bin(TimeGenerated, 1h)\n    | summarize PartialFailedSignins = count(), LatestAnomalyTime = arg_max(TimeGenerated, *) by bin(TimeGenerated, 1h), OperationName, Category, ResultType, ResultDescription, UserPrincipalName, Roles, UserDisplayName, AppDisplayName, ClientAppUsed, IPAddress, ResourceDisplayName\n) on UserPrincipalName, $left.AnomalyHour == $right.DateHour\n| project LatestAnomalyTime, OperationName, Category, UserPrincipalName, Roles = todynamic(Roles), UserDisplayName, ResultType, ResultDescription, AppDisplayName, ClientAppUsed, UserAgent, IPAddress, Location, AuthenticationRequirement, ConditionalAccessStatus, ResourceDisplayName, PartialFailedSignins, TotalFailedSignins = HourlyCount, baseline, anomalies, score\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "TargetUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Privileged Role Assigned Outside PIM",
      "id": "269435e3-1db8-4423-9dfc-9bf59997da1c",
      "tactics": "PrivilegeEscalation",
      "kind": "Scheduled",
      "description": "'Identifies a privileged role being assigned to a user outside of PIM\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "PrivlegedRoleAssignedOutsidePIM.yaml",
      "queryFrequency": "PT1D",
      "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where OperationName has \"Add member to role outside of PIM\"\n        or (LoggedByService =~ \"Core Directory\" and OperationName =~ \"Add member to role\" and Identity != \"MS-PIM\" and Identity != \"MS-PIM-Fairfax\")\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend TargetUserPrincipalName = tostring(TargetResource.userPrincipalName)\n  )\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend TargetName = tostring(split(TargetUserPrincipalName,'@',0)[0]), TargetUPNSuffix = tostring(split(TargetUserPrincipalName,'@',1)[0])\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatedBy"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Name",
              "columnName": "TargetResourceName"
            }
          ],
          "entityType": "CloudApplication"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT7D",
      "name": "Rare application consent",
      "id": "83ba3057-9ea3-4759-bf6a-933f2e5bc7ee",
      "tactics": [
        "Persistence",
        "PrivilegeEscalation"
      ],
      "kind": "Scheduled",
      "description": "'This will alert when the \"Consent to application\" operation occurs by a user that has not done this operation before or rarely does this.\nThis could indicate that permissions to access the listed Azure App were provided to a malicious actor.\nConsent to application, Add service principal and Add OAuth2PermissionGrant should typically be rare events.\nThis may help detect the Oauth2 attack that can be initiated by this publicly available tool - https://github.com/fireeye/PwnAuth\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 3,
      "sourceFile": "RareApplicationConsent.yaml",
      "queryFrequency": "PT1D",
      "query": "let current = 1d;\nlet auditLookback = 7d;\n// Setting threshold to 3 as a default, change as needed.\n// Any operation that has been initiated by a user or app more than 3 times in the past 7 days will be excluded\nlet threshold = 3;\n// Gather initial data from lookback period, excluding current, adjust current to more than a single day if no results\nlet AuditTrail = AuditLogs | where TimeGenerated >= ago(auditLookback) and TimeGenerated < ago(current)\n// 2 other operations that can be part of malicious activity in this situation are\n// \"Add OAuth2PermissionGrant\" and \"Add service principal\", extend the filter below to capture these too\n| where OperationName has \"Consent to application\"\n| extend InitiatedBy = iff(isnotempty(tostring(InitiatedBy.user.userPrincipalName)),\n          tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend TargetResourceName = tolower(tostring(TargetResource.displayName))\n  )\n| summarize max(TimeGenerated), OperationCount = count() by OperationName, InitiatedBy, TargetResourceName\n// only including operations initiated by a user or app that is above the threshold so we produce only rare and has not occurred in last 7 days\n| where OperationCount > threshold;\n// Gather current period of audit data\nlet RecentConsent = AuditLogs | where TimeGenerated >= ago(current)\n| where OperationName has \"Consent to application\"\n| extend IpAddress = case(\n              isnotempty(tostring(InitiatedBy.user.ipAddress)) and tostring(InitiatedBy.user.ipAddress) != 'null', tostring(InitiatedBy.user.ipAddress),\n              isnotempty(tostring(InitiatedBy.app.ipAddress)) and tostring(InitiatedBy.app.ipAddress) != 'null', tostring(InitiatedBy.app.ipAddress),\n              'Not Available')\n| extend InitiatedBy = iff(isnotempty(tostring(InitiatedBy.user.userPrincipalName)),\n                          tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend TargetResourceName = tolower(tostring(TargetResource.displayName)),\n               props = TargetResource.modifiedProperties\n  )\n| parse props with * \"ConsentType: \" ConsentType \"]\" *\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| project TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType, UserAgent, CorrelationId, Type;\n// Exclude previously seen audit activity for \"Consent to application\" that was seen in the lookback period\n// First for rare InitiatedBy\nlet RareConsentBy = RecentConsent | join kind= leftanti AuditTrail on OperationName, InitiatedBy\n| extend Reason = \"Previously unseen user consenting\";\n// Second for rare TargetResourceName\nlet RareConsentApp = RecentConsent | join kind= leftanti AuditTrail on OperationName, TargetResourceName\n| extend Reason = \"Previously unseen app granted consent\";\nRareConsentBy | union RareConsentApp\n| summarize Reason = make_set(Reason,100) by TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType, UserAgent, CorrelationId, Type\n| extend timestamp = TimeGenerated, Name = tolower(tostring(split(InitiatedBy,'@',0)[0])), UPNSuffix = tolower(tostring(split(InitiatedBy,'@',1)[0]))",
      "techniques": [
        "T1136",
        "T1068"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "Rare subscription-level operations in Azure",
      "id": "23de46ea-c425-4a77-b456-511ae4855d69",
      "tactics": [
        "CredentialAccess",
        "Persistence"
      ],
      "kind": "Scheduled",
      "description": "'This query looks for a few sensitive subscription-level events based on Azure Activity Logs. For example, this monitors for the operation name 'Create or Update Snapshot', which is used for creating backups but could be misused by attackers to dump hashes or extract sensitive information from the disk.'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "RareOperations.yaml",
      "queryFrequency": "PT1D",
      "query": "let starttime = 14d;\nlet endtime = 1d;\n// The number of operations above which an IP address is considered an unusual source of role assignment operations\nlet alertOperationThreshold = 5;\n// Add or remove operation names below as per your requirements. For operations lists, please refer to https://learn.microsoft.com/en-us/Azure/role-based-access-control/resource-provider-operations#all\nlet SensitiveOperationList =  dynamic([\"microsoft.compute/snapshots/write\", \"microsoft.network/networksecuritygroups/write\", \"microsoft.storage/storageaccounts/listkeys/action\"]);\nlet SensitiveActivity = AzureActivity\n| where OperationNameValue in~ (SensitiveOperationList) or OperationNameValue hassuffix \"listkeys/action\"\n| where ActivityStatusValue =~ \"Success\";\nSensitiveActivity\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| summarize count() by CallerIpAddress, Caller, OperationNameValue, bin(TimeGenerated,1d)\n| where count_ >= alertOperationThreshold\n// Returns all the records from the right side that don't have matches from the left\n| join kind = rightanti (\nSensitiveActivity\n| where TimeGenerated >= ago(endtime)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = make_list(TimeGenerated), ActivityStatusValue = make_list(ActivityStatusValue), CorrelationIds = make_list(CorrelationId), ResourceGroups = make_list(ResourceGroup), ResourceIds = make_list(_ResourceId), ActivityCountByCallerIPAddress = count()\nby CallerIpAddress, Caller, OperationNameValue\n| where ActivityCountByCallerIPAddress >= alertOperationThreshold\n) on CallerIpAddress, Caller, OperationNameValue\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])",
      "techniques": [
        "T1003",
        "T1098"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "Password spray attack against Microsoft Entra ID Seamless SSO",
      "id": "fb7ca1c9-e14c-40a3-856e-28f3c14ea1ba",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'This query detects when there is a spike in Microsoft Entra ID Seamless SSO errors. They may not be caused by a Password Spray attack, but the cause of the errors might need to be investigated.\nMicrosoft Entra ID only logs the requests that matched existing accounts, thus there might have been unlogged requests for non-existing accounts.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SeamlessSSOPasswordSpray.yaml",
      "queryFrequency": "PT1H",
      "query": "let account_threshold = 5;\nAADNonInteractiveUserSignInLogs\n//| where ResultType == \"81016\"\n| where ResultType startswith \"81\"\n| summarize DistinctAccounts = dcount(UserPrincipalName), DistinctAddresses = make_set(IPAddress,100) by ResultType\n| where DistinctAccounts > account_threshold\n| mv-expand IPAddress = DistinctAddresses\n| extend IPAddress = tostring(IPAddress)\n| join kind=leftouter (union isfuzzy=true SigninLogs, AADNonInteractiveUserSignInLogs) on IPAddress\n| summarize\n    StartTime = min(TimeGenerated),\n    EndTime = max(TimeGenerated),\n    UserPrincipalName = make_set(UserPrincipalName,100),\n    UserAgent = make_set(UserAgent,100),\n    ResultDescription = take_any(ResultDescription),\n    ResultSignature = take_any(ResultSignature)\n    by IPAddress, Type, ResultType\n| project Type, StartTime, EndTime, IPAddress, ResultType, ResultDescription, ResultSignature, UserPrincipalName, UserAgent = iff(array_length(UserAgent) == 1, UserAgent[0], UserAgent)\n| extend Name = tostring(split(UserPrincipalName[0],'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName[0],'@',1)[0])",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "FullName",
            "columnName": "UserPrincipalName"
          },
          {
            "identifier": "Name",
            "columnName": "Name"
          },
          {
            "identifier": "UPNSuffix",
            "columnName": "UPNSuffix"
          }
        ],
        "entityType": "Account"
      },
      "queryPeriod": "PT1H",
      "name": "GitHub Signin Burst from Multiple Locations",
      "id": "d3980830-dd9d-40a5-911f-76b44dfdce16",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'This detection triggers when there is a Signin burst from multiple locations in GitHub (Entra ID SSO).\n This detection is based on configurable threshold which can be prone to false positives. To view the anomaly based equivalent of thie detection, please see here https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20Entra%20ID/Analytic%20Rules/AnomalousUserAppSigninLocationIncrease-detection.yaml. '",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "Sign-in Burst from Multiple Locations.yaml",
      "queryFrequency": "PT1H",
      "query": "let locationThreshold = 1;\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where AppDisplayName =~ \"GitHub.com\"\n| where ResultType == 0\n| summarize CountOfLocations = dcount(Location), Locations = make_set(Location,100), BurstStartTime = min(TimeGenerated), BurstEndTime = max(TimeGenerated) by UserPrincipalName, Type\n| where CountOfLocations > locationThreshold\n| extend timestamp = BurstStartTime\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Address",
            "columnName": "IPAddress"
          }
        ],
        "entityType": "IP"
      },
      "queryPeriod": "PT1D",
      "name": "Sign-ins from IPs that attempt sign-ins to disabled accounts",
      "id": "500c103a-0319-4d56-8e99-3cec8d860757",
      "tactics": [
        "InitialAccess",
        "Persistence"
      ],
      "kind": "Scheduled",
      "description": "'Identifies IPs with failed attempts to sign in to one or more disabled accounts using the IP through which successful signins from other accounts have happened.\nThis could indicate an attacker who obtained credentials for a list of accounts and is attempting to login with those accounts, some of which may have already been disabled.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n50057 - User account is disabled. The account has been disabled by an administrator.\nThis query has also been updated to include UEBA logs IdentityInfo and BehaviorAnalytics for contextual information around the results.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SigninAttemptsByIPviaDisabledAccounts.yaml",
      "queryFrequency": "PT1D",
      "query": "let aadFunc = (tableName: string) {\nlet failed_signins = table(tableName)\n| where ResultType == \"50057\"\n| where ResultDescription == \"User account is disabled. The account has been disabled by an administrator.\";\nlet disabled_users = failed_signins | summarize by UserPrincipalName;\ntable(tableName)\n  | where ResultType == 0\n  | where isnotempty(UserPrincipalName)\n  | where UserPrincipalName !in (disabled_users)\n| summarize\n        successfulAccountsTargettedCount = dcount(UserPrincipalName),\n        successfulAccountSigninSet = make_set(UserPrincipalName, 100),\n        successfulApplicationSet = make_set(AppDisplayName, 100)\n    by IPAddress, Type\n    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe\n    | where successfulAccountsTargettedCount < 50\n    | where isnotempty(successfulAccountsTargettedCount)\n  | join kind=inner (failed_signins\n| summarize\n    StartTime = min(TimeGenerated),\n    EndTime = max(TimeGenerated),\n    totalDisabledAccountLoginAttempts = count(),\n    disabledAccountsTargettedCount = dcount(UserPrincipalName),\n    applicationsTargeted = dcount(AppDisplayName),\n    disabledAccountSet = make_set(UserPrincipalName, 100),\n    disabledApplicationSet = make_set(AppDisplayName, 100)\nby IPAddress, Type\n| order by totalDisabledAccountLoginAttempts desc) on IPAddress\n| project StartTime, EndTime, IPAddress, totalDisabledAccountLoginAttempts, disabledAccountsTargettedCount, disabledAccountSet, disabledApplicationSet, successfulApplicationSet, successfulAccountsTargettedCount, successfulAccountSigninSet, Type\n| order by totalDisabledAccountLoginAttempts};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n| join kind=leftouter (\n    BehaviorAnalytics\n    | where ActivityType in (\"FailedLogOn\", \"LogOn\")\n    | where EventSource =~ \"Azure AD\"\n    | project UsersInsights, DevicesInsights, ActivityInsights, InvestigationPriority, SourceIPAddress, UserPrincipalName\n    | project-rename IPAddress = SourceIPAddress\n    | summarize\n        Users = make_set(UserPrincipalName, 100),\n        UsersInsights = make_set(UsersInsights, 100),\n        DevicesInsights = make_set(DevicesInsights, 100),\n        IPInvestigationPriority = sum(InvestigationPriority)\n    by IPAddress\n) on IPAddress\n| extend SFRatio = toreal(toreal(disabledAccountsTargettedCount)/toreal(successfulAccountsTargettedCount))\n| where SFRatio >= 0.5\n| sort by IPInvestigationPriority desc",
      "techniques": [
        "T1078",
        "T1098"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "UserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT7D",
      "name": "Brute force attack against Azure Portal",
      "id": "28b42356-45af-40a6-a0b4-a554cdfd5d8a",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "Detects Azure Portal brute force attacks by monitoring for multiple authentication failures and a successful login within a 20-minute window. Default settings: 10 failures, 25 deviations.\nRef: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes.",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SigninBruteForce-AzurePortal.yaml",
      "queryFrequency": "PT1D",
      "query": "// Set threshold value for deviation\nlet threshold = 25;\n// Set the time range for the query\nlet timeRange = 24h;\n// Set the authentication window duration\nlet authenticationWindow = 20m;\n// Define a reusable function 'aadFunc' that takes a table name as input\nlet aadFunc = (tableName: string) {\n  // Query the specified table\n  table(tableName)\n  // Filter data within the last 24 hours\n  | where TimeGenerated > ago(1d)\n  // Filter records related to \"Azure Portal\" applications\n  | where AppDisplayName has \"Azure Portal\"\n  // Extract and transform some fields\n  | extend\n      DeviceDetail = todynamic(DeviceDetail),\n      LocationDetails = todynamic(LocationDetails)\n  | extend\n      OS = tostring(DeviceDetail.operatingSystem),\n      Browser = tostring(DeviceDetail.browser),\n      State = tostring(LocationDetails.state),\n      City = tostring(LocationDetails.city),\n      Region = tostring(LocationDetails.countryOrRegion)\n  // Categorize records as Success or Failure based on ResultType\n  | extend FailureOrSuccess = iff(ResultType in (\"0\", \"50125\", \"50140\", \"70043\", \"70044\"), \"Success\", \"Failure\")\n  // Sort and identify sessions\n  | sort by UserPrincipalName asc, TimeGenerated asc\n  | extend SessionStartedUtc = row_window_session(TimeGenerated, timeRange, authenticationWindow, UserPrincipalName != prev(UserPrincipalName) or prev(FailureOrSuccess) == \"Success\")\n  // Summarize data\n  | summarize FailureOrSuccessCount = count() by  FailureOrSuccess, UserId, UserDisplayName, AppDisplayName, IPAddress, Browser, OS, State, City, Region, Type, CorrelationId, bin(TimeGenerated, authenticationWindow), ResultType, UserPrincipalName, SessionStartedUtc\n  | summarize FailureCountBeforeSuccess = sumif(FailureOrSuccessCount, FailureOrSuccess == \"Failure\"), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), makelist(FailureOrSuccess), IPAddress = make_set(IPAddress, 15), make_set(Browser, 15), make_set(City, 15), make_set(State, 15), make_set(Region, 15), make_set(ResultType, 15) by SessionStartedUtc, UserPrincipalName, CorrelationId, AppDisplayName, UserId, Type\n  // Filter records where \"Success\" occurs in the middle of a session\n  | where array_index_of(list_FailureOrSuccess, \"Success\") != 0\n  | where array_index_of(list_FailureOrSuccess, \"Success\") == array_length(list_FailureOrSuccess) - 1\n  // Remove unnecessary columns from the output\n  | project-away SessionStartedUtc, list_FailureOrSuccess\n  // Join with another table and calculate deviation\n  | join kind=inner (\n      table(tableName)\n      | where TimeGenerated > ago(7d)\n      | where AppDisplayName has \"Azure Portal\"\n      | extend FailureOrSuccess = iff(ResultType in (\"0\", \"50125\", \"50140\", \"70043\", \"70044\"), \"Success\", \"Failure\")\n      | summarize avgFailures = avg(todouble(FailureOrSuccess == \"Failure\")) by UserPrincipalName\n  ) on UserPrincipalName\n  | extend Deviation = abs(FailureCountBeforeSuccess - avgFailures) / avgFailures\n  // Filter records based on deviation and failure count criteria\n  | where Deviation > threshold and FailureCountBeforeSuccess >= 10\n  // Expand the IPAddress array\n  | mv-expand IPAddress\n  | extend IPAddress = tostring(IPAddress)\n  | extend timestamp = StartTime\n};\n// Call 'aadFunc' with different table names and union the results\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n// Additional transformation - Split UserPrincipalName\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": {
        "fieldMappings": [
          {
            "identifier": "Address",
            "columnName": "IPAddress"
          }
        ],
        "entityType": "IP"
      },
      "queryPeriod": "PT7D",
      "name": "Password spray attack against Microsoft Entra ID application",
      "id": "48607a29-a26a-4abf-8078-a06dbdd174a4",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'Identifies evidence of password spray activity against Microsoft Entra ID applications by looking for failures from multiple accounts from the same IP address within a time window. If the number of accounts breaches the threshold just once, all failures from the IP address within the time range are bought into the result. Details on whether there were successful authentications by the IP address within the time window are also included.\nThis can be an indicator that an attack was successful.\nThe default failure acccount threshold is 5, Default time window for failures is 20m and default look back window is 1 day\nNote: Due to the number of possible accounts involved in a password spray it is not possible to map identities to a custom entity.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SigninPasswordSpray.yaml",
      "queryFrequency": "PT1D",
      "query": "let timeRange = 1d;\nlet lookBack = 7d;\nlet authenticationWindow = 20m;\nlet authenticationThreshold = 5;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet failureCodes = dynamic([50053, 50126, 50055]); // invalid password, account is locked - too many sign ins, expired password\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\n// Lookup up resolved identities from last 7 days\nlet aadFunc = (tableName:string){\nlet identityLookup = table(tableName)\n| where TimeGenerated >= ago(lookBack)\n| where not(Identity matches regex isGUID)\n| where isnotempty(UserId)\n| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName, Type;\n// collect window threshold breaches\ntable(tableName)\n| where TimeGenerated > ago(timeRange)\n| where ResultType in(failureCodes)\n| summarize FailedPrincipalCount = dcount(UserPrincipalName) by bin(TimeGenerated, authenticationWindow), IPAddress, AppDisplayName, Type\n| where FailedPrincipalCount >= authenticationThreshold\n| summarize WindowThresholdBreaches = count() by IPAddress, Type\n| join kind= inner (\n// where we breached a threshold, join the details back on all failure data\ntable(tableName)\n| where TimeGenerated > ago(timeRange)\n| where ResultType in(failureCodes)\n| extend LocationDetails = todynamic(LocationDetails)\n| extend FullLocation = strcat(LocationDetails.countryOrRegion,'|', LocationDetails.state, '|', LocationDetails.city)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), make_set(ClientAppUsed,20), make_set(FullLocation,20), FailureCount = count() by IPAddress, AppDisplayName, UserPrincipalName, UserDisplayName, Identity, UserId, Type\n// lookup any unresolved identities\n| extend UnresolvedUserId = iff(Identity matches regex isGUID, UserId, \"\")\n| join kind= leftouter (\n identityLookup\n) on $left.UnresolvedUserId==$right.UserId\n| extend UserDisplayName=iff(isempty(lu_UserDisplayName), UserDisplayName, lu_UserDisplayName)\n| extend UserPrincipalName=iff(isempty(lu_UserPrincipalName), UserPrincipalName, lu_UserPrincipalName)\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), make_set(UserPrincipalName,20), make_set(UserDisplayName,20), make_set(set_ClientAppUsed,20), make_set(set_FullLocation,20), make_list(FailureCount,20) by IPAddress, AppDisplayName, Type\n| extend FailedPrincipalCount = array_length(set_UserPrincipalName)\n) on IPAddress\n| project IPAddress, StartTime, EndTime, TargetedApplication=AppDisplayName, FailedPrincipalCount, UserPrincipalNames=set_UserPrincipalName, UserDisplayNames=set_UserDisplayName, ClientAppsUsed=set_set_ClientAppUsed, Locations=set_set_FullLocation, FailureCountByPrincipal=list_FailureCount, WindowThresholdBreaches, Type\n| join kind= inner (\ntable(tableName) // get data on success vs. failure history for each IP\n| where TimeGenerated > ago(timeRange)\n| where ResultType in(successCodes) or ResultType in(failureCodes) // success or failure types\n| summarize GlobalSuccessPrincipalCount = dcountif(UserPrincipalName, (ResultType in (successCodes))), ResultTypeSuccesses = make_set_if(ResultType, (ResultType in (successCodes))), GlobalFailPrincipalCount = dcountif(UserPrincipalName, (ResultType in (failureCodes))), ResultTypeFailures = make_set_if(ResultType, (ResultType in (failureCodes))) by IPAddress, Type\n| where GlobalFailPrincipalCount > GlobalSuccessPrincipalCount // where the number of failed principals is greater than success - eliminates FPs from IPs who authenticate successfully alot and as a side effect have alot of failures\n) on IPAddress\n| project-away IPAddress1\n| extend timestamp=StartTime\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt",
      "techniques": "T1110",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "ResourceId",
              "columnName": "_ResourceId"
            }
          ],
          "entityType": "AzureResource"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CallerIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT15M",
      "name": "Subnet created or updated without an NSG",
      "id": "1e0a7d9c-8b44-4b7c-9bfa-8e1d4ed7e98a",
      "tactics": "DefenseEvasion",
      "kind": "Scheduled",
      "description": "'Detects creation or update of a virtual network subnet where no Network Security Group (NSG) is associated. Subnets without an NSG can unintentionally expose workloads by removing a key enforcement layer for inbound and outbound traffic controls.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SubnetWithoutNSGAssociation.yaml",
      "queryFrequency": "PT15M",
      "query": "let queryFrequency = 15m;\nAzureActivity\n| where ingestion_time() > ago(queryFrequency)\n| where ActivityStatusValue =~ \"Success\"\n| where tolower(OperationNameValue) =~ \"microsoft.network/virtualnetworks/subnets/write\"\n| extend requestBody = tostring(parse_json(Properties).requestbody)\n| extend request = parse_json(requestBody)\n| extend subnetProps = coalesce(request.properties, request.Properties)\n| extend NSGId = tostring(coalesce(subnetProps.networkSecurityGroup.id, subnetProps.networkSecurityGroup.Id))\n| where isempty(NSGId)\n| extend Name = tostring(split(Caller,'@',0)[0]), UPNSuffix = tostring(split(Caller,'@',1)[0])\n| project\n    TimeGenerated,\n    Caller,\n    Name,\n    UPNSuffix,\n    CallerIpAddress,\n    OperationNameValue,\n    ResourceGroup,\n    _ResourceId,\n    Resource,\n    CorrelationId,\n    NSGId",
      "techniques": "T1562",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "ResourceId",
              "columnName": "_ResourceId"
            }
          ],
          "entityType": "AzureResource"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        }
      ],
      "queryPeriod": "PT20M",
      "name": "Subscription moved to another tenant",
      "id": "48c026d8-7f36-4a95-9568-6f1420d66e37",
      "tactics": "Impact",
      "kind": "Scheduled",
      "description": "'This detection uses AzureActivity logs (Security category) to identify when a subscription is moved to another tenant.\nA threat actor may move a subscription into their own tenant to circumvent local resource deployment and logging policies.\nOnce moved, threat actors may deploy resources and perform malicious activities such as crypto mining.\nThis is a technique known as \"subscription hijacking\". More information can be found here: https://techcommunity.microsoft.com/t5/microsoft-365-defender-blog/hunt-for-compromised-azure-subscriptions-using-microsoft/ba-p/3607121'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SubscriptionMigration.yaml",
      "queryFrequency": "PT5M",
      "query": "let queryFrequency = 5m;\nlet eventCapture = \"moved from tenant ([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}) to tenant ([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\";\nAzureActivity\n| where ingestion_time() > ago(queryFrequency)\n| where CategoryValue =~ \"Security\"\n| where OperationNameValue =~ \"Microsoft.Subscription/updateTenant/action\"\n| extend Properties_d = coalesce(parse_json(Properties), Properties_d)\n| where isnotempty(Properties_d)\n| extend Summary = tostring(Properties_d.message)\n| extend EventCapture = extract_all(eventCapture, Summary)\n| extend SourceTenantId = iff(isnotempty(EventCapture), EventCapture[0][0], \"\")\n| extend DestinationTenantId = iff(isnotempty(EventCapture), EventCapture[0][1], \"\")\n| extend \n    Name = split(Caller, \"@\", 0)[0],\n    UPNSuffix = split(Caller, \"@\", 1)[0]",
      "techniques": "T1496",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "SuccessIPAddress"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "FailedIPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Successful logon from IP and failure from a different IP",
      "id": "02ef8d7e-fc3a-4d86-a457-650fa571d8d2",
      "tactics": [
        "CredentialAccess",
        "InitialAccess"
      ],
      "kind": "Scheduled",
      "description": "'Identifies when a user account successfully logs onto an Azure App from one IP and within 10 mins failed to logon to the same App via a different IP (may indicate a malicious attempt at password guessing with known account). \nUEBA added for context to gather all asoociated information assocaited with IP addressed initiating Faile Logon and affected user. \nPlease note, Failed logons from known IP ranges can be benign depending on the conditional access policies. In case of noisy behavior, consider tuning the source IP ranges after careful consideration'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SuccessThenFail_DiffIP_SameUserandApp.yaml",
      "queryFrequency": "PT1D",
      "query": "let riskScoreCutoff = 3; //Adjust this score threshold based on volume of results. Activities identified as the most abnormal receive the highest scores (on a scale of 0-10)\nlet logonDiff = 10m; \nlet aadFunc = (tableName:string)\n{ \ntable(tableName)\n| where ResultType == \"0\"\n| where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\") // To remove false-positives, add more Apps to this array\n// ---------- Fix for SuccessBlock to also consider IPv6\n| extend SuccessIPv6Block = strcat(split(IPAddress, \":\")[0], \":\", split(IPAddress, \":\")[1], \":\", split(IPAddress, \":\")[2], \":\", split(IPAddress, \":\")[3])\n| extend SuccessIPv4Block = strcat(split(IPAddress, \".\")[0], \".\", split(IPAddress, \".\")[1])\n// ------------------\n| project SuccessLogonTime = TimeGenerated, UserPrincipalName, SuccessIPAddress = IPAddress, SuccessLocation = Location, AppDisplayName, SuccessIPBlock = iff(IPAddress contains \":\", strcat(split(IPAddress, \":\")[0], \":\", split(IPAddress, \":\")[1]), strcat(split(IPAddress, \".\")[0], \".\", split(IPAddress, \".\")[1])), Type\n| join kind= inner (\n    table(tableName)\n    | where ResultType !in (\"0\", \"50140\")\n    | where ResultDescription !~ \"Other\"\n    | where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\")\n    | project FailedLogonTime = TimeGenerated, UserPrincipalName, FailedIPAddress = IPAddress, FailedLocation = Location, AppDisplayName, ResultType, ResultDescription, Type \n) on UserPrincipalName, AppDisplayName\n| where SuccessLogonTime < FailedLogonTime and FailedLogonTime - SuccessLogonTime <= logonDiff and FailedIPAddress !startswith SuccessIPBlock\n| summarize FailedLogonTime = max(FailedLogonTime), SuccessLogonTime = max(SuccessLogonTime) by UserPrincipalName, SuccessIPAddress, SuccessLocation, AppDisplayName, FailedIPAddress, FailedLocation, ResultType, ResultDescription, Type\n| extend timestamp = SuccessLogonTime\n| extend UserPrincipalName = tolower(UserPrincipalName)};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])\n// UEBA context below - make sure you have these 2 datatypes, otherwise the query will not work. If so, comment all that is below.\n| join kind=leftouter (\n    IdentityInfo\n    | summarize LatestReportTime = arg_max(TimeGenerated, *) by AccountUPN\n    | project AccountUPN, Tags, JobTitle, GroupMembership, AssignedRoles, UserType, IsAccountEnabled\n    | summarize\n        Tags = make_set(Tags, 1000),\n        GroupMembership = make_set(GroupMembership, 1000),\n        AssignedRoles = make_set(AssignedRoles, 1000),\n        UserType = make_set(UserType, 1000),\n        UserAccountControl = make_set(UserType, 1000)\n    by AccountUPN\n    | extend UserPrincipalName=tolower(AccountUPN)\n) on UserPrincipalName\n//Below it will be joined with BehaviorAnalytics table to the Failed IP Addresses\n| join kind=leftouter (\n    BehaviorAnalytics\n    | where ActivityType in (\"FailedLogOn\", \"LogOn\")\n    | where isnotempty(SourceIPAddress)\n    | project UsersInsights, DevicesInsights, ActivityInsights, InvestigationPriority, SourceIPAddress, UserName\n    | project-rename FailedIPAddress = SourceIPAddress, Name = UserName\n    | summarize\n        MaxInvestigationScore = max(InvestigationPriority)  // Only retrieve maximum Investigation Property score for both FailedIP and User\n    by FailedIPAddress, Name)\non FailedIPAddress, Name  // Joining on both IP and User so as to only return context associated with same user\n| extend UEBARiskScore = MaxInvestigationScore\n| project-away *1 // removing duplicate columns post outer join from output\n| where  UEBARiskScore > riskScoreCutoff\n| sort by UEBARiskScore desc",
      "techniques": [
        "T1110",
        "T1078"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "HostName",
              "columnName": "NewDeviceName"
            }
          ],
          "entityType": "Host"
        },
        {
          "fieldMappings": [
            {
              "identifier": "HostName",
              "columnName": "OldDeviceName"
            }
          ],
          "entityType": "Host"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AzureID",
              "columnName": "DeviceId"
            }
          ],
          "entityType": "Host"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Suspicious Entra ID Joined Device Update",
      "id": "3a3c6835-0086-40ca-b033-a93bf26d878f",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'This query looks for suspicious updates to an Microsoft Entra ID joined device where the device name is changed and the device falls out of compliance.\nThis could occur when a threat actor updates the details of an Autopilot provisioned device using a stolen device ticket, in order to access certificates and keys.\nRef: https://dirkjanm.io/assets/raw/Insomnihack%20Breaking%20and%20fixing%20Azure%20AD%20device%20identity%20security.pdf'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SuspiciousAADJoinedDeviceUpdate.yaml",
      "queryFrequency": "PT1D",
      "query": "AuditLogs\n| where OperationName =~ \"Update device\"\n| mv-apply TargetResource=TargetResources on (\n    where TargetResource.type =~ \"Device\"\n    | extend ModifiedProperties = TargetResource.modifiedProperties\n    | extend DeviceId = TargetResource.id)\n| mv-apply Prop=ModifiedProperties on ( \n    where Prop.displayName =~ \"CloudDisplayName\"\n    | extend OldName = Prop.oldValue \n    | extend NewName = Prop.newValue)\n| mv-apply Prop=ModifiedProperties on ( \n    where Prop.displayName =~ \"IsCompliant\"\n    | extend OldComplianceState = Prop.oldValue  \n    | extend NewComplianceState = Prop.newValue)\n| mv-apply Prop=ModifiedProperties on ( \n    where Prop.displayName =~ \"TargetId.DeviceTrustType\"\n    | extend OldTrustType = Prop.oldValue  \n    | extend NewTrustType = Prop.newValue)\n| mv-apply Prop=ModifiedProperties on ( \n    where Prop.displayName =~ \"Included Updated Properties\" \n    | extend UpdatedProperties = Prop.newValue)\n| extend OldDeviceName = tostring(parse_json(tostring(OldName))[0])\n| extend NewDeviceName = tostring(parse_json(tostring(NewName))[0])\n| extend OldComplianceState = tostring(parse_json(tostring(OldComplianceState))[0])\n| extend NewComplianceState = tostring(parse_json(tostring(NewComplianceState))[0])\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend UpdatedPropertiesCount = array_length(split(UpdatedProperties, ','))\n| where OldDeviceName != NewDeviceName\n| where OldComplianceState =~ 'true' and NewComplianceState =~ 'false'\n// Most common is transferring from AAD Registered to AAD Joined - we just want AAD Joined devices\n| where NewTrustType == '\"AzureAd\"' and OldTrustType != '\"Workplace\"'\n// We can modify this value to tune FPs - more properties changed about the device beyond its name the more suspicious it could be\n| where UpdatedPropertiesCount > 1\n| project-reorder TimeGenerated, DeviceId, NewDeviceName, OldDeviceName, NewComplianceState, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, AADOperationType, OldTrustType, NewTrustType, UpdatedProperties, UpdatedPropertiesCount\n| extend InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1528",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "GrantInitiatedByUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "GrantInitiatedByAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "GrantInitiatedByAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "GrantIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "Suspicious application consent for offline access",
      "id": "3533f74c-9207-4047-96e2-0eb9383be587",
      "tactics": "CredentialAccess",
      "kind": "Scheduled",
      "description": "'This will alert when a user consents to provide a previously-unknown Azure application with offline access via OAuth.\nOffline access will provide the Azure App with access to the listed resources without requiring two-factor authentication.\nConsent to applications with offline access and read capabilities should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SuspiciousOAuthApp_OfflineAccess.yaml",
      "queryFrequency": "PT1D",
      "query": "let detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated > ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"offline\"\n| mv-apply TargetResource=TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend ModifiedProperties = TargetResource.modifiedProperties,\n               AppDisplayName = tostring(TargetResource.displayName),\n               AppClientId = tolower(tostring(TargetResource.id))\n  )\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| mv-apply Properties=ModifiedProperties on \n  (\n      where Properties.displayName =~ \"ConsentAction.Permissions\"\n      | extend ConsentFull = tostring(Properties.newValue)\n      | extend ConsentFull = trim(@'\"',tostring(ConsentFull))\n  )\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull has \"offline_access\" and ConsentFull has_any (\"Files.Read\", \"Mail.Read\", \"Notes.Read\", \"ChannelMessage.Read\", \"Chat.Read\", \"TeamsActivity.Read\", \"Group.Read\", \"EWS.AccessAsUser.All\", \"EAS.AccessAsUser.All\")\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantInitiatedByAppName = tostring(InitiatedBy.app.displayName)\n| extend GrantInitiatedByAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend GrantInitiatedByUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend GrantInitiatedByAadUserId = tostring(InitiatedBy.user.id)\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| extend GrantInitiatedBy = iff(isnotempty(GrantInitiatedByUserPrincipalName), GrantInitiatedByUserPrincipalName, GrantInitiatedByAppName)\n| extend GrantUserAgent = tostring(iff(AdditionalDetails[0].key =~ \"User-Agent\", AdditionalDetails[0].value, \"\"))\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantInitiatedByUserPrincipalName, GrantInitiatedByAadUserId, GrantInitiatedByAppName, GrantInitiatedByAppServicePrincipalId, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n| mv-apply TargetResource=TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend ModifiedProperties = TargetResource.modifiedProperties,\n               AppClientId = tolower(TargetResource.id)\n  )\n| mv-apply ModifiedProperties=TargetResource.modifiedProperties on \n   (\n      where ModifiedProperties.displayName =~ \"AppAddress\" and ModifiedProperties.newValue has \"AddressType\"\n      | extend AppReplyURLs = ModifiedProperties.newValue\n   )\n | distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n | mv-apply TargetResource=TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n      | extend GrantAuthentication = tostring(TargetResource.displayName)\n  )\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantInitiatedByUserPrincipalName, GrantInitiatedByAadUserId, GrantInitiatedByAppName, GrantInitiatedByAppServicePrincipalId, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n| extend Name = tostring(split(GrantInitiatedByUserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(GrantInitiatedByUserPrincipalName,'@',1)[0])",
      "techniques": "T1528",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "CreatorUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "CreatorName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "CreatorUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "DeleterUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "DeleterName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "DeleterSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "CreatorIPAddress"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "DeleterIPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1H10M",
      "name": "Suspicious Service Principal creation activity",
      "id": "6852d9da-8015-4b95-8ecf-d9572ee0395d",
      "tactics": [
        "CredentialAccess",
        "PrivilegeEscalation",
        "InitialAccess"
      ],
      "kind": "Scheduled",
      "description": "'This alert will detect creation of an SPN, permissions granted, credentials created, activity and deletion of the SPN in a time frame (default 10 minutes)'",
      "severity": "Low",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SuspiciousServicePrincipalcreationactivity.yaml",
      "queryFrequency": "PT1H",
      "query": "let queryfrequency = 1h;\nlet wait_for_deletion = 10m;\nlet account_created =\n  AuditLogs \n  | where ActivityDisplayName == \"Add service principal\"\n  | where Result == \"success\"\n  | extend AppID = tostring(AdditionalDetails[1].value)\n  | extend creationTime = ActivityDateTime\n  | extend CreatorUserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend CreatorIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress);\nlet account_activity =\n  AADServicePrincipalSignInLogs\n  | extend Activities = pack(\"ActivityTime\", TimeGenerated ,\"IpAddress\", IPAddress, \"ResourceDisplayName\", ResourceDisplayName)\n  | extend AppID = AppId\n  | summarize make_list(Activities) by AppID;\nlet account_deleted =\n  AuditLogs \n  | where OperationName == \"Remove service principal\"\n  | where Result == \"success\"\n  | extend AppID = tostring(AdditionalDetails[1].value)\n  | extend deletionTime = ActivityDateTime\n  | extend DeleterUserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend DeleterIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress);\nlet account_credentials =\n  AuditLogs\n  | where OperationName has_all (\"Update application\", \"Certificates and secrets management\")\n  | where Result == \"success\"\n  | extend AppID = tostring(AdditionalDetails[1].value)\n  | extend credentialCreationTime = ActivityDateTime;\nlet roles_assigned =\n  AuditLogs\n  | where ActivityDisplayName == \"Add app role assignment to service principal\"\n  | extend AppID = tostring(TargetResources[1].displayName)\n  | extend AssignedRole =  iff(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].displayName)==\"AppRole.Value\", tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue))),\"\")\n  | extend AssignedRoles = pack(\"Role\", AssignedRole)\n  | summarize make_list(AssignedRoles) by AppID;\naccount_created\n| where TimeGenerated between (ago(wait_for_deletion+queryfrequency)..ago(wait_for_deletion))\n| join kind= inner (account_activity) on AppID\n| join kind= inner (account_deleted) on AppID\n| join kind= inner (account_credentials) on AppID\n| join kind= inner (roles_assigned) on AppID\n| where deletionTime - creationTime between (time(0s)..wait_for_deletion)\n| extend AliveTime = deletionTime - creationTime\n| project AADTenantId, AppID, creationTime, deletionTime, CreatorUserPrincipalName, DeleterUserPrincipalName, CreatorIPAddress, DeleterIPAddress, list_Activities, list_AssignedRoles, AliveTime\n| extend CreatorName = tostring(split(CreatorUserPrincipalName, \"@\")[0]), CreatorUPNSuffix = tostring(split(CreatorUserPrincipalName, \"@\")[1])\n| extend DeleterName = tostring(split(DeleterUserPrincipalName, \"@\")[0]), DeleterSuffix = tostring(split(DeleterUserPrincipalName, \"@\")[1])",
      "techniques": [
        "T1078",
        "T1528"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatorUPN"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatorName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatorUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatorID"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "TargetUPN"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "TargetId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "FromIP"
            }
          ],
          "entityType": "IP"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "SourceIPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "Suspicious Sign In Followed by MFA Modification",
      "id": "aec77100-25c5-4254-a20a-8027ed92c46c",
      "tactics": [
        "InitialAccess",
        "DefenseEvasion"
      ],
      "kind": "Scheduled",
      "description": "'This query looks uses Microsoft Sentinel's UEBA features to look for suspicious logons followed by modifications to MFA settings by that user.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "SuspiciousSignInFollowedByMFAModification.yaml",
      "queryFrequency": "PT1D",
      "query": "let PriorityScore = 9;\nBehaviorAnalytics\n| where ActionType == \"Sign-in\"\n| where InvestigationPriority > PriorityScore\n| extend UserPrincipalName = tolower(UserPrincipalName)\n| extend LogOnTime = TimeGenerated\n| join kind=inner (AuditLogs\n| where Category =~ \"UserManagement\" \n| where OperationName in~ (\"Admin registered security info\", \"Admin updated security info\", \"Admin deleted security info\", \"User registered security info\", \"User changed default security info\", \"User deleted security info\",\"User registered all required security info\",\"User started security info registration\") \n| extend InitiatorUPN = tolower(tostring(InitiatedBy.user.userPrincipalName))\n| extend InitiatorID = tostring(InitiatedBy.user.id)\n| extend FromIP = tostring(InitiatedBy.user.ipAddress) \n| extend TargetUPN = tolower(tostring(TargetResources[0].userPrincipalName))\n| extend TargetId = tostring(TargetResources[0].id)\n| extend MFAModTime = TimeGenerated\n| where isnotempty(InitiatorUPN)) on $left.UserPrincipalName == $right.InitiatorUPN\n| where MFAModTime between((LogOnTime-30m)..(LogOnTime+1h))\n| extend InitiatorName = tostring(split(InitiatorUPN, \"@\")[0]), InitiatorUPNSuffix = tostring(split(InitiatorUPN, \"@\")[1]), TargetName = tostring(split(TargetUPN, \"@\")[0]), TargetUPNSuffix = tostring(split(TargetUPN, \"@\")[1])",
      "techniques": [
        "T1078.004",
        "T1556.006"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Caller"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "AadUserId"
            }
          ],
          "entityType": "Account"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "Mass Cloud resource deletions Time Series Anomaly",
      "id": "ed43bdb7-eaab-4ea4-be52-6951fcfa7e3b",
      "tactics": "Impact",
      "kind": "Scheduled",
      "description": "'This query generates the baseline pattern of cloud resource deletions by an individual and generates an anomaly when any unusual spike is detected. These anomalies from unusual or privileged users could be an indication of a cloud infrastructure takedown by an adversary.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "TimeSeriesAnomaly_Mass_Cloud_Resource_Deletions.yaml",
      "queryFrequency": "PT1D",
      "query": "let starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1d;\nlet TotalEventsThreshold = 25;\nlet TimeSeriesData = AzureActivity \n| where TimeGenerated between (startofday(ago(starttime))..startofday(now())) \n| where OperationNameValue endswith \"delete\" \n| project TimeGenerated, Caller \n| make-series Total = count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by Caller;\nTimeSeriesData \n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 3, -1, 'linefit') \n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long) \n| where TimeGenerated >= startofday(ago(endtime)) \n| where anomalies > 0 \n| project Caller, TimeGenerated, Total, baseline, anomalies, score \n| where Total > TotalEventsThreshold and baseline > 0 \n| join (AzureActivity \n| where TimeGenerated > startofday(ago(endtime)) \n| where OperationNameValue endswith \"delete\" \n| summarize count(), make_set(OperationNameValue,100), make_set(_ResourceId,100) by bin(TimeGenerated, timeframe), Caller ) on TimeGenerated, Caller \n| extend Name = iif(Caller has '@',tostring(split(Caller,'@',0)[0]),\"\")\n| extend UPNSuffix = iif(Caller has '@',tostring(split(Caller,'@',1)[0]),\"\")\n| extend AadUserId = iif(Caller !has '@',Caller,\"\")",
      "techniques": "T1485",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InvitedUser"
            },
            {
              "identifier": "Name",
              "columnName": "InvitedUserName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InvitedUserUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatedByName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatedByUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1D",
      "name": "External guest invitation followed by Microsoft Entra ID PowerShell signin",
      "id": "acc4c247-aaf7-494b-b5da-17f18863878a",
      "tactics": [
        "InitialAccess",
        "Persistence",
        "Discovery"
      ],
      "kind": "Scheduled",
      "description": "'By default guests have capability to invite more external guest users, guests also can do suspicious Microsoft Entra ID enumeration. This detection look at guest users, who have been invited or have invited recently, who also are logging via various PowerShell CLI.\nRef : 'https://danielchronlund.com/2021/11/18/scary-azure-ad-tenant-enumeration-using-regular-b2b-guest-accounts/'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "UnusualGuestActivity.yaml",
      "queryFrequency": "PT1H",
      "query": "let queryfrequency = 1h;\nlet queryperiod = 1d;\nAuditLogs\n| where TimeGenerated > ago(queryperiod)\n| where OperationName in (\"Invite external user\", \"Bulk invite users - started (bulk)\", \"Invite external user with reset invitation status\")\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend InitiatedBy = iff(isnotempty(InitiatingUserPrincipalName), InitiatingUserPrincipalName, InitiatingAppName)\n// Uncomment the following line to filter events where the inviting user was a guest user\n//| where InitiatedBy has_any (\"live.com#\", \"#EXT#\")\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend InvitedUser = tostring(TargetResource.userPrincipalName)\n  )\n| mv-expand UserToCompare = pack_array(InitiatedBy, InvitedUser) to typeof(string)\n| where UserToCompare has_any (\"live.com#\", \"#EXT#\")\n| extend\n    parsedUser = replace_string(tolower(iff(UserToCompare startswith \"live.com#\", tostring(split(UserToCompare, \"#\")[1]), tostring(split(UserToCompare, \"#EXT#\")[0]))), \"@\", \"_\"),\n    InvitationTime = TimeGenerated\n| join (\n    (union isfuzzy=true SigninLogs, AADNonInteractiveUserSignInLogs)\n    | where TimeGenerated > ago(queryfrequency)\n    | where UserType != \"Member\"\n    | where AppId has_any                       // This web may contain a list of these apps: https://msshells.net/\n        (\"1b730954-1685-4b74-9bfd-dac224a7b894\",// Azure Active Directory PowerShell\n         \"04b07795-8ddb-461a-bbee-02f9e1bf7b46\",// Microsoft Azure CLI\n         \"1950a258-227b-4e31-a9cf-717495945fc2\",// Microsoft Azure PowerShell\n         \"a0c73c16-a7e3-4564-9a95-2bdf47383716\",// Microsoft Exchange Online Remote PowerShell\n         \"fb78d390-0c51-40cd-8e17-fdbfab77341b\",// Microsoft Exchange REST API Based Powershell\n         \"d1ddf0e4-d672-4dae-b554-9d5bdfd93547\",// Microsoft Intune PowerShell\n         \"9bc3ab49-b65d-410a-85ad-de819febfddc\",// Microsoft SharePoint Online Management Shell\n         \"12128f48-ec9e-42f0-b203-ea49fb6af367\",// MS Teams Powershell Cmdlets\n         \"23d8f6bd-1eb0-4cc2-a08c-7bf525c67bcd\",// Power BI PowerShell\n         \"31359c7f-bd7e-475c-86db-fdb8c937548e\",// PnP Management Shell\n         \"90f610bf-206d-4950-b61d-37fa6fd1b224\",// Aadrm Admin Powershell\n         \"14d82eec-204b-4c2f-b7e8-296a70dab67e\",// Microsoft Graph PowerShell\n         \"9cee029c-6210-4654-90bb-17e6e9d36617\" // Power Platform CLI - pac\"\n        )\n    | summarize arg_min(TimeGenerated, *) by UserPrincipalName\n    | extend\n        parsedUser = replace_string(UserPrincipalName, \"@\", \"_\"),\n        SigninTime = TimeGenerated\n    )\n    on parsedUser\n| project InvitationTime, InitiatedBy, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, OperationName, InvitedUser, SigninTime, SigninCategory = Category1, SigninUserPrincipalName = UserPrincipalName, AppDisplayName, ResourceDisplayName, UserAgent, InvitationAdditionalDetails = AdditionalDetails, InvitationTargetResources = TargetResources\n| extend InvitedUserName = tostring(split(InvitedUser,'@',0)[0]), InvitedUserUPNSuffix = tostring(split(InvitedUser,'@',1)[0]), \n         InitiatedByName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatedByUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": [
        "T1078.004",
        "T1136.003",
        "T1087.004"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "UserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "Name"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "UPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "IPAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "User Accounts - Sign in Failure due to CA Spikes",
      "id": "3a9d5ede-2b9d-43a2-acc4-d272321ff77c",
      "tactics": "InitialAccess",
      "kind": "Scheduled",
      "description": "' Identifies spike in failed sign-ins from user accounts due to conditional access policied.\nSpike is determined based on Time series anomaly which will look at historical baseline values.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins\nThis query has also been updated to include UEBA logs IdentityInfo and BehaviorAnalytics for contextual information around the results.'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "UserAccounts-CABlockedSigninSpikes.yaml",
      "queryFrequency": "PT1D",
      "query": "let riskScoreCutoff = 20; //Adjust this based on volume of results\nlet starttime = 14d;\nlet timeframe = 1d;\nlet scorethreshold = 3;\nlet baselinethreshold = 50;\nlet aadFunc = (tableName:string){\n  // Failed Signins attempts with reasoning related to conditional access policies.\n  table(tableName)\n  | where TimeGenerated between (startofday(ago(starttime))..startofday(now()))\n  | where ResultDescription has_any (\"conditional access\", \"CA\") or ResultType in (50005, 50131, 53000, 53001, 53002, 52003, 70044)\n  | extend UserPrincipalName = tolower(UserPrincipalName)\n  | extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nlet allSignins = union isfuzzy=true aadSignin, aadNonInt;\nlet TimeSeriesAlerts = \nallSignins\n| make-series DailyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step 1d by UserPrincipalName\n| extend (anomalies, score, baseline) = series_decompose_anomalies(DailyCount, scorethreshold, -1, 'linefit')\n| mv-expand DailyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n// Filtering low count events per baselinethreshold\n| where anomalies > 0 and baseline > baselinethreshold\n| extend AnomalyHour = TimeGenerated\n| project UserPrincipalName, AnomalyHour, TimeGenerated, DailyCount, baseline, anomalies, score;\n// Filter the alerts for specified timeframe\nTimeSeriesAlerts\n| where TimeGenerated > startofday(ago(timeframe))\n| join kind=inner ( \n  allSignins\n  | where TimeGenerated > startofday(ago(timeframe))\n  // create a new column and round to hour\n  | extend DateHour = bin(TimeGenerated, 1h)\n  | summarize PartialFailedSignins = count(), LatestAnomalyTime = arg_max(TimeGenerated, *) by bin(TimeGenerated, 1h), OperationName, Category, ResultType, ResultDescription, UserPrincipalName, UserDisplayName, AppDisplayName, ClientAppUsed, IPAddress, ResourceDisplayName\n) on UserPrincipalName, $left.AnomalyHour == $right.DateHour\n| project LatestAnomalyTime, OperationName, Category, UserPrincipalName, UserDisplayName, ResultType, ResultDescription, AppDisplayName, ClientAppUsed, UserAgent, IPAddress, Location, AuthenticationRequirement, ConditionalAccessStatus, ResourceDisplayName, PartialFailedSignins, TotalFailedSignins = DailyCount, baseline, anomalies, score\n| extend timestamp = LatestAnomalyTime, Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])\n| extend UserPrincipalName = tolower(UserPrincipalName)\n| join kind=leftouter (\n    IdentityInfo\n    | summarize LatestReportTime = arg_max(TimeGenerated, *) by AccountUPN\n    | project AccountUPN, Tags, JobTitle, GroupMembership, AssignedRoles, UserType, IsAccountEnabled\n    | summarize\n        Tags = make_set(Tags, 1000),\n        GroupMembership = make_set(GroupMembership, 1000),\n        AssignedRoles = make_set(AssignedRoles, 1000),\n        UserType = make_set(UserType, 1000),\n        UserAccountControl = make_set(UserType, 1000)\n    by AccountUPN\n    | extend UserPrincipalName=tolower(AccountUPN)\n) on UserPrincipalName\n| join kind=leftouter (\n    BehaviorAnalytics\n    | where ActivityType in (\"FailedLogOn\", \"LogOn\")\n    | where isnotempty(SourceIPAddress)\n    | project UsersInsights, DevicesInsights, ActivityInsights, InvestigationPriority, SourceIPAddress\n    | project-rename IPAddress = SourceIPAddress\n    | summarize\n        UsersInsights = make_set(UsersInsights, 1000),\n        DevicesInsights = make_set(DevicesInsights, 1000),\n        IPInvestigationPriority = sum(InvestigationPriority)\n    by IPAddress)\non IPAddress\n| extend UEBARiskScore = IPInvestigationPriority\n| where UEBARiskScore > riskScoreCutoff\n| sort by UEBARiskScore desc",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "AccountName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "AccountUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "TargetUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT1H",
      "name": "User added to Microsoft Entra ID Privileged Groups",
      "id": "4d94d4a9-dc96-410a-8dea-4d4d4584188b",
      "tactics": [
        "Persistence",
        "PrivilegeEscalation"
      ],
      "kind": "Scheduled",
      "description": "'This will alert when a user is added to any of the Privileged Groups.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\nFor Administrator role permissions in Microsoft Entra ID please see https://docs.microsoft.com/azure/active-directory/users-groups-roles/directory-assign-admin-roles'",
      "severity": "Medium",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "UseraddedtoPrivilgedGroups.yaml",
      "queryFrequency": "PT1H",
      "query": "let OperationList = dynamic([\"Add member to role\",\"Add eligible member to role\"]);\nlet PrivilegedGroups = dynamic([\"UserAccountAdmins\",\"PrivilegedRoleAdmins\",\"TenantAdmins\",\"PrivilegedAuthenticationAdmins\"]);\nAuditLogs\n| where Category =~ \"RoleManagement\"\n| where OperationName in~ (OperationList)\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend TargetUserPrincipalName = tostring(TargetResource.userPrincipalName),\n               modProps = TargetResource.modifiedProperties\n  )\n| mv-apply Property = modProps on \n  (\n      where Property.displayName =~ \"Role.WellKnownObjectName\"\n      | extend DisplayName = trim('\"',tostring(Property.displayName)),\n               GroupName = trim('\"',tostring(Property.newValue))\n  )\n| extend InitiatingAppId = InitiatedBy.app.appId\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingAppServicePrincipalName = tostring(InitiatedBy.app.servicePrincipalName)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend InitiatingUserRoles = InitiatedBy.user.roles\n| where GroupName in~ (PrivilegedGroups)\n// If you don't want to alert for operations from PIM, remove below filtering for MS-PIM.\n//| where InitiatingAppName != \"MS-PIM\" and InitiatingAppName != \"MS-PIM-Fairfax\"\n| project TimeGenerated, AADOperationType, Category, OperationName, AADTenantId, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppId, InitiatingAppName, InitiatingAppServicePrincipalName, InitiatingAppServicePrincipalId, InitiatingIpAddress, DisplayName, GroupName, InitiatingUserRoles, TargetUserPrincipalName\n| extend AccountName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), AccountUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])\n| extend TargetName = tostring(split(TargetUserPrincipalName,'@',0)[0]), TargetUPNSuffix = tostring(split(TargetUserPrincipalName,'@',1)[0])",
      "techniques": [
        "T1098",
        "T1078"
      ],
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Target"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatorName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatorUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT2H",
      "name": "User Assigned New Privileged Role",
      "id": "746ddb63-f51b-4563-b449-a8b13cf302ec",
      "tactics": "Persistence",
      "kind": "Scheduled",
      "description": "'Identifies when a new eligible or active privileged role is assigned to a user. Does not alert on PIM activations. Any account eligible for a role is now being given privileged access. If the assignment is unexpected or into a role that isn't the responsibility of the account holder, investigate.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "UserAssignedNewPrivilegedRole.yaml",
      "queryFrequency": "PT2H",
      "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where AADOperationType in (\"Assign\", \"AssignEligibleRole\", \"CreateRequestGrantedRole\", \"CreateRequestPermanentEligibleRole\", \"CreateRequestPermanentGrantedRole\")\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-apply TargetResourceSubject = TargetResources on \n  (\n      where TargetResourceSubject.type in~ (\"User\", \"ServicePrincipal\")\n      | extend Target = iff(TargetResourceSubject.type =~ \"ServicePrincipal\", tostring(TargetResourceSubject.displayName), tostring(TargetResourceSubject.userPrincipalName)),\n               subjectProps = TargetResourceSubject.modifiedProperties\n  )\n| mv-apply TargetResourceRole = TargetResources on \n  (\n    // mimic modifiedProperties so we can use the same logic to get the role name regardless of where it comes from\n    where TargetResourceRole.type in~ (\"Role\")\n    | extend roleProps = pack_array(bag_pack(\"displayName\",\"Role.DisplayName\", \"newValue\", TargetResourceRole.displayName))\n  )\n| mv-apply Property = iff(array_length(subjectProps) > 0, subjectProps, roleProps) on \n  ( \n    where Property.displayName =~ \"Role.DisplayName\"\n      | extend RoleName = trim('\"',tostring(Property.newValue))\n  )\n| where RoleName contains \"Admin\"\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend Initiator = iif(isnotempty(InitiatingAppName), InitiatingAppName, InitiatingUserPrincipalName)\n// Comment below to alert for PIM activations\n| where Initiator != \"MS-PIM\" and Initiator != \"MS-PIM-Fairfax\"\n| summarize by bin(TimeGenerated, 1h), OperationName, RoleName, Target, Initiator, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, Result\n| extend TargetName = tostring(split(Target,'@',0)[0]), TargetUPNSuffix = tostring(split(Target,'@',1)[0]), InitiatorName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatorUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1078.004",
      "enabled": true
    },
    {
      "entityMappings": [
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "Target"
            },
            {
              "identifier": "Name",
              "columnName": "TargetName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "TargetUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "FullName",
              "columnName": "InitiatingUserPrincipalName"
            },
            {
              "identifier": "Name",
              "columnName": "InitiatorName"
            },
            {
              "identifier": "UPNSuffix",
              "columnName": "InitiatorUPNSuffix"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAadUserId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "AadUserId",
              "columnName": "InitiatingAppServicePrincipalId"
            }
          ],
          "entityType": "Account"
        },
        {
          "fieldMappings": [
            {
              "identifier": "Address",
              "columnName": "InitiatingIpAddress"
            }
          ],
          "entityType": "IP"
        }
      ],
      "queryPeriod": "PT14D",
      "name": "New User Assigned to Privileged Role",
      "id": "050b9b3d-53d0-4364-a3da-1b678b8211ec",
      "tactics": "Persistence",
      "kind": "Scheduled",
      "description": "Identifies when a privileged role is assigned to a new user. Any account eligible for a role is now being given privileged access. If the assignment is unexpected or into a role that isn't the responsibility of the account holder, investigate.",
      "severity": "High",
      "triggerOperator": "gt",
      "triggerThreshold": 0,
      "sourceFile": "UserAssignedPrivilegedRole.yaml",
      "queryFrequency": "PT1H",
      "query": "// Define the start and end times based on input values\nlet starttime = now()-1h;\nlet endtime = now();\n// Set a lookback period of 14 days\nlet lookback = starttime - 14d;\n// Define a reusable function to query audit logs\nlet awsFunc = (start:datetime, end:datetime) {\n  AuditLogs\n  | where TimeGenerated between (start..end)\n  | where Category =~ \"RoleManagement\"\n  | where AADOperationType in (\"Assign\", \"AssignEligibleRole\")\n  | where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n  | mv-apply TargetResource = TargetResources on\n    (\n      where TargetResource.type in~ (\"User\", \"ServicePrincipal\")\n      | extend Target = iff(TargetResource.type =~ \"ServicePrincipal\", tostring(TargetResource.displayName), tostring(TargetResource.userPrincipalName)),\n      props = TargetResource.modifiedProperties\n    )\n  | mv-apply Property = props on\n    (\n      where Property.displayName =~ \"Role.DisplayName\"\n      | extend RoleName = trim('\"', tostring(Property.newValue))\n    )\n  | where RoleName contains \"Admin\" and Result == \"success\"\n};\n// Query for audit events in the current day\nlet EventInfo_CurrentDay = awsFunc(starttime, endtime);\n// Query for audit events in the historical period (lookback)\nlet EventInfo_historical = awsFunc(lookback, starttime);\n// Find unseen events by performing a left anti-join\nlet EventInfo_Unseen = (EventInfo_CurrentDay\n  | join kind=leftanti(EventInfo_historical) on Target, RoleName, OperationName\n);\n// Extend and clean up the results\nEventInfo_Unseen\n| extend InitiatingAppName = tostring(InitiatedBy.app.displayName)\n| extend InitiatingAppServicePrincipalId = tostring(InitiatedBy.app.servicePrincipalId)\n| extend InitiatingUserPrincipalName = tostring(InitiatedBy.user.userPrincipalName)\n| extend InitiatingAadUserId = tostring(InitiatedBy.user.id)\n| extend InitiatingIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend Initiator = iif(isnotempty(InitiatingAppName), InitiatingAppName, InitiatingUserPrincipalName)\n// You can uncomment the lines below to filter out PIM activations\n// | where Initiator != \"MS-PIM\" and Initiator != \"MS-PIM-Fairfax\"\n// | summarize StartTime=min(TimeGenerated), EndTime=min(TimeGenerated) by OperationName, RoleName, Target, Initiator, Result\n// Project specific columns and split them for further analysis\n| project TimeGenerated, OperationName, RoleName, Target, Initiator, InitiatingUserPrincipalName, InitiatingAadUserId, InitiatingAppName, InitiatingAppServicePrincipalId, InitiatingIpAddress, Result\n| extend TargetName = tostring(split(Target,'@',0)[0]), TargetUPNSuffix = tostring(split(Target,'@',1)[0]), InitiatorName = tostring(split(InitiatingUserPrincipalName,'@',0)[0]), InitiatorUPNSuffix = tostring(split(InitiatingUserPrincipalName,'@',1)[0])",
      "techniques": "T1078.004",
      "enabled": true
    }
  ],
  "generatedAt": "2026-02-12T13:36:12.3399455-05:00",
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#"
}
